#include "RPG.dh"

#include "Arena.dh"
#include "Map.dh"
#include "Mission.dh"
#include "Monsters.dh"
#include "Namegen.dh"
#include "Popoffs.dh"
#include "Shield.dh"
#include "Stats.dh"
#include "Utils.dh"

AddressSpace MapArray MonsterSpace;
AddressSpace MapArray MonsterStatsSpace;

MapRegister int MonsterID = 1;

MonsterStatsSpace MonsterStats[MAX_MONSTERS] Monsters;

MonsterSpace MonsterInfo[MAX_DEF_MONSTERS] MonsterData =
{
    { "ZombieMan";                          "Former Human";             1;      0; "You hear shuffling footsteps and moans!"; };
    { "ShotgunGuy";                         "Former Sergeant";          2;      0; "You hear the sound of shotguns pumping!"; };
    { "ChaingunGuy";                        "Former Commando";          5;      0; "Quiet mutters and whirring set you on edge!"; };
    { "DoomImp";                            "Imp";                      4;      0; "The walls are scratched and flame-scorched!"; };
    { "Demon";                              "Demon";                    3;      0; "Hungry growls echo around you!"; };
    { "Spectre";                            "Spectre";                  3;      0; "It's dark, you are likely to be eaten by a... Spectre?"; };
    { "LostSoul";                           "Lost Soul";                3;      0; "The sound of many flames echo about!"; };
    { "Cacodemon";                          "Cacodemon";                10;     0; "Screeches drown out all other sound!"; };
    { "HellKnight";                         "Hell Knight";              20;     0; "A battle cry chants in the distance!"; };
    { "BaronOfHell";                        "Baron of Hell";            30;     0; "Seems you've found Hell's nobility!"; };
    { "PainElemental";                      "Pain Elemental";           40;     0; "You feel you are being watched!"; };
    { "Revenant";                           "Revenant";                 50;     0; "Bones clatter all around you!"; };
    { "Fatso";                              "Mancubus";                 60;     0; "You hear deep, guttural noises!"; };
    { "Arachnotron";                        "Arachnotron";              60;     0; "Leg servos squeak and whirr nearby!"; };
    { "ArchVile";                           "Arch-Vile";                70;     0; "You hear crackling flames!"; };
    { "Cyberdemon";                         "Cyberdemon";               85;     0; "Suddenly you have a great urge to turn back! You scream in TERROR!"; };
    { "SpiderMastermind";                   "Spider Mastermind";        95;     0; "You've stumbled into a hive of the deadliest kind!"; };
};

MonsterSpace MonsterInfo[MAX_DEF_MONSTERS_DRLA] MonsterDataDRLA =
{
    // Normal
    { "RLFormerHuman";                      "Former Human";             1;      0; "You hear shuffling footsteps and moans!"; };
    { "RLFormerSergeant";                   "Former Sergeant";          2;      0; "You hear the sound of shotguns pumping!"; };
    { "RLFormerCommando";                   "Former Commando";          5;      0; "Quiet mutters and whirring set you on edge!"; };
    { "RLFormerCaptain";                    "Former Captain";           8;      0; "The sound of a plasma rifle priming makes you flinch!"; };
    { "RLImp";                              "Imp";                      4;      0; "The walls are scratched and flame-scorched!"; };
    { "RLDemon";                            "Demon";                    3;      0; "Hungry growls echo around you!"; };
    { "RLSpectre";                          "Spectre";                  3;      0; "It's dark, you are likely to be eaten by a... Spectre?"; };
    { "RLLostSoul";                         "Lost Soul";                3;      0; "The sound of many flames echo about!"; };
    { "RLCacodemon";                        "Cacodemon";                10;     0; "Screeches drown out all other sound!"; };
    { "RLHellKnight";                       "Hell Knight";              20;     0; "A battle cry chants in the distance!"; };
    { "RLBaronOfHell";                      "Baron of Hell";            30;     0; "Seems you've found Hell's nobility!"; };
    { "RLPainElemental";                    "Pain Elemental";           40;     0; "You feel you are being watched!"; };
    { "RLRevenant";                         "Revenant";                 50;     0; "Bones clatter all around you!"; };
    { "RLMancubus";                         "Mancubus";                 60;     0; "You hear deep, guttural noises!"; };
    { "RLArachnotron";                      "Arachnotron";              60;     0; "Leg servos squeak and whirr nearby!"; };
    { "RLArchvile";                         "Arch-Vile";                70;     0; "You hear crackling flames!"; };
    { "RLCyberdemon";                       "Cyberdemon";               87;     0; "Suddenly you have a great urge to turn back!\nYou scream in TERROR!"; };
    { "RLSpiderMastermind";                 "Spider Mastermind";        95;     0; "You've stumbled into a hive of the deadliest kind!"; };
    { "RLAgonyElemental";                   "Agony Elemental";          100;    0; "You feel the presence of great conduits of the damned!"; };
    
    // Nightmare
    { "RLEliteHuman";                       "Elite Human";              5;      1; "The sound of heavy gunshots alerts you!"; };
    { "RLEliteSergeant";                    "Elite Sergeant";           8;      1; "Veteran soldiers patrol the halls, seeking you!"; };
    { "RLEliteCommando";                    "Elite Commando";           12;     1; "Heavy ammo belts rustle and clank in the dark!"; };
    { "RLEliteCaptain";                     "Elite Captain";            15;     1; "You notice some power cells on the floor, used only by the most powerful weapons!"; };
    { "RLNightmareImp";                     "Nightmare Imp";            8;      1; "You notice dark nebulous enemies are hunting you down!"; };
    { "RLNightmareDemon";                   "Nightmare Demon";          6;      1; "Roars and growls fill the air!"; };
    { "RLNightmareSpectre";                 "Nightmare Spectre";        6;      1; "You feel you are being stalked by something unseen!"; };
    { "RLNightmareLostSoul";                "Nightmare Soul";           6;      1; "You feel like you are being haunted!"; };
    { "RLNightmareCacodemon";               "Nightmare Cacodemon";      14;     1; "The air is crackling with electricity!"; };
    { "RLNightmareHellKnight";              "Nightmare Knight";         25;     1; "Heavy hoofsteps echo through the chambers!"; };
    { "RLNightmareBaronOfHell";             "Baron of Nightmares";      45;     1; "Commanding roars warn you of danger ahead!"; };
    { "RLNightmareArachnotron";             "Nightmare Arachnotron";    65;     1; "The charging of heavy plasma guns fills the air with humming!"; };
    { "RLNightmarePainElemental";           "Nightmare Elemental";      60;     1; "You feel like Hell's invisible influence is leaking into this area faster!"; };
    { "RLNightmareRevenant";                "Nightmare Revenant";       70;     1; "Distant screams echo through the air and your mind!"; };
    { "RLNightmareMancubus";                "Nightmare Mancubus";       85;     1; "You hear deep growling and the priming of heavy plasma cannons!"; };
    { "RLNightmareArchvile";                "Nightmare Vile";           90;     1; "You suddenly break out in a flash sweat!"; };
    { "RLNightmareCyberdemon";              "Nightmare Cyberdemon";     100;    1; "Surrounded by hooves and deep laughter, you know you will not leave alive!"; };
    
    // Cybernetic
    { "RLCyberneticImp";                    "Cyber-Imp";                6;      1; "Arcs of electricity and howling creatures greet you!"; };
    { "RLCyberneticDemon";                  "Mech-Demon";               5;      1; "Stomping metal feet ring in your ears!"; };
    { "RLCyberneticSpectre";                "Mechtre";                  5;      1; "You hear the sound of a cloaking device shorting out!"; };
    { "RLCyberneticLostSoul";               "Hellmine";                 1;      1; "It's quiet...\ntoo quiet..."; };
    { "RLCyberneticHellKnight";             "Cybruiser";                43;     1; "Clanking footsteps herald Hell's mechanical legions!"; };
    { "RLCyberneticBaronOfHell";            "Techno-Lord";              45;     1; "Uneven footsteps marks the arrival of some of Hell's cyberforces!"; };
    { "RLCyberneticArachnotron";            "Arachnosentinel";          62;     1; "The walls are covered in bullet holes!"; };
    { "RLCyberneticMancubus";               "Volacubus";                65;     1; "The smell of burning fuel fills this area!"; };
    { "RLCyberneticRevenant";               "Heavy Revenant";           70;     1; "Seems they needed bigger rocket launchers!"; };
    { "RLCyberneticSpiderMastermind";       "Spider Overmind";          97;     1; "You hear endless whispering in your mind!\nYou feel your resistance slipping!"; };
    
    // Armageddon
    // ...
};

MonsterSpace str[MAX_HUMANS][2] MonsterHumanData =
{
    // Former
    { "RLFormerHumanPistol";            "RLFormerHuman";    };
    { "RLFormerHumanBattleRifle";       "RLFormerHuman";    };
    { "RLFormerHumanBattleRifle2";      "RLFormerHuman";    };
    { "RLFormerHumanBattleRifle3";      "RLFormerHuman";    };
    { "RLFormerSergeantShotgun";        "RLFormerSergeant"; };
    { "RLFormerSergeantCombatShotgun";  "RLFormerSergeant"; };
    { "RLFormerCommandoChaingun";       "RLFormerCommando"; };
    { "RLFormerCommandoBattleRifle";    "RLFormerCommando"; };
    { "RLFormerCaptainPlasmaRifle";     "RLFormerCaptain";  };
    
    // Elite
    { "RLEliteHumanCombatPistol";       "RLEliteHuman";     };
    { "RLEliteHumanHandcannon";         "RLEliteHuman";     };
    { "RLEliteHumanBattleRifle";        "RLEliteHuman";     };
    { "RLEliteHumanBattleRifle2";       "RLEliteHuman";     };
    { "RLEliteHumanUzi";                "RLEliteHuman";     };
    { "RLEliteSergeantDoubleShotgun";   "RLEliteSergeant";  };
    { "RLEliteSergeantAssaultShotgun";  "RLEliteSergeant";  };
    { "RLEliteSergeantPlasmaShotgun";   "RLEliteSergeant";  };
    { "RLEliteCommandoMinigun";         "RLEliteCommando";  };
    { "RLEliteCaptainTristarBlaster";   "RLEliteCaptain";   };
};

MonsterSpace MegabossInfo[MAX_MEGABOSSES] MegaBosses =
{
    { "DRPGMegabossPride";   "Pride"; };
    { "DRPGMegabossSloth";   "Sloth"; };
};

function int NewMonsterID()
{
    int CurrentID = MonsterID++;
    if (CurrentID >= MAX_MONSTERS)
    {
        MonsterID = MAX_MONSTERS;
        return 0;
    };
    
    // When re-using an existing ID, all of these need to be reset so Init knows what to do with them
    Monsters[CurrentID].Actor = nullptr;
    Monsters[CurrentID].ReplaceActor = "";
    Monsters[CurrentID].Flags = 0;
    Monsters[CurrentID].RenderStyle = 0;
    Monsters[CurrentID].SpawnHealth = 0;
    Monsters[CurrentID].HealthMax = 0;
    Monsters[CurrentID].Speed = 0;
    Monsters[CurrentID].Height = 0;
    Monsters[CurrentID].Radius = 0;
    Monsters[CurrentID].NeedReinit = false;
    Monsters[CurrentID].HealthBar = false;
    Monsters[CurrentID].Named = false;
    Monsters[CurrentID].Reinforcement = false;
    Monsters[CurrentID].Target = 0;
    Monsters[CurrentID].Level = 0;
    Monsters[CurrentID].Aura.Time = 0;
    for (int i = 0; i < AURA_MAX; i++)
    {
        Monsters[CurrentID].Aura.Type[i].Active = false;
        Monsters[CurrentID].Aura.Type[i].Level = 0;
    };
    Monsters[CurrentID].Threat = 0;
    Monsters[CurrentID].Strength = 0;
    Monsters[CurrentID].Defense = 0;
    Monsters[CurrentID].Vitality = 0;
    Monsters[CurrentID].Energy = 0;
    Monsters[CurrentID].Regeneration = 0;
    Monsters[CurrentID].Agility = 0;
    Monsters[CurrentID].Capacity = 0;
    Monsters[CurrentID].Luck = 0;
    
    return CurrentID;
};

// Monster Init Script
acscript void MonsterInit(int Flags)
{
    // Get a new ID for the monster
    if (GetMonsterID(0) == 0)
        SetMonsterID(0, NewMonsterID());
    
    if (GetMonsterID(0) == 0)
    {
        // The monster couldn't be given an ID, so there's nothing we can possibly do here.
        Thing_Remove(0);
        return;
    };
    
    // Monster Stats Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // If initialization has already occurred on this monster, terminate
    if (Stats->Init) return;
    
    // Store TID
    if (ActivatorTID() == 0)
    {
        int TID = UniqueTID();
        Thing_ChangeTID(0, TID);
        Stats->TID = TID;
    }
    else
        Stats->TID = ActivatorTID();
    
    // Store Position
    Stats->Position = { GetActorX(0); GetActorY(0); GetActorZ(0); GetActorAngle(0); GetActorPitch(0); };
    
    // Set as initialized
    Stats->Init = true;
    SetInventory("DRPGMonsterInit", 1);
    
    // Store Actor Name
    Stats->Actor = GetActorClass(0);
    
    Delay(1); // Allow map events to modify our stats/replacements (see Map.ds:18)
    while (WaitingForReplacements)
        Delay(1);
    
    if (!Stats->Init)
        return; // Monster Reducer removed us
    
    if (StrLen(Stats->ReplaceActor) > 0)
    {
        Thing_Remove(0);
        Stats->Init = false;
        if (StrICmp(Stats->ReplaceActor, "None") != 0)
            Spawn(Stats->ReplaceActor, Stats->Position.X, Stats->Position.Y, Stats->Position.Z, ActivatorTID(), Stats->Position.Angle * 256);
        return;        
    };
    
    // Store Monster Flags
    Stats->Flags = Flags;
    
    // Set the Height and Radius
    Stats->Height = GetActorPropertyFixed(0, APROP_Height);
    Stats->Radius = GetActorPropertyFixed(0, APROP_Radius);
    
    // Apply base Spawn Health to HealthMax property
    Stats->SpawnHealth = GetActorProperty(0, APROP_SpawnHealth);
    Stats->HealthMax = Stats->SpawnHealth;
    
    // Start Damage Numbers Script
    DamageNumbers();
    
    // Give it a Health Bar
    if (!(Flags & MF_NOHEALTHBAR))
        Stats->HealthBar = true;
    
    // Apply Stats
    if (!(Flags & MF_NOSTATS))
        MonsterInitStats();
    
    // Save the Render Type
    Stats->RenderStyle = GetActorProperty(0, APROP_RenderStyle);
    
    // Stat-Change Handling
    MonsterStatsHandler();
    
    // Aura Spawner
    MonsterAuraDisplayHandler();
    
    // Regeneration Stat Handling
    if (!(Flags & MF_NOSTATS))
        MonsterRegenerationHandler();
    
    // Death Handler
    MonsterDeathCheck();
    
    // Environmental Hazard Map Event
    if (CurrentLevel->Event == MAPEVENT_TOXICHAZARD && (Random(1, 8) == 1 || Stats->Flags & MF_BOSS || Stats->Flags & MF_MEGABOSS))
    {
        GiveInventory("DRPGMonsterRadiationProtection", 1);
        GiveInventory("DRPGMonsterRadSuit", 1);
    };
};

// Modify the targeted monster (mainly for debugging)
acscript void MonsterSet(int Level, int Aura, int Flags)
{
    // Move script to the targeted monster
    SetActivatorToTarget(Player.TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // Set Stats/Flags
    if (Level > 0)
        Stats->Level = Level;
    if (Aura > 0)
        Stats->Aura.Type[Aura - 1].Active = true;
    if (Flags > 0)
        Stats->Flags = Flags;
    
    // Needs reinitialization to apply new info
    Stats->NeedReinit = true;
};

// Give the targeted monster a Shadow Aura (mainly for debugging)
acscript void MonsterSetShadow()
{
    // Move script to the targeted monster
    SetActivatorToTarget(Player.TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // Apply all Auras
    for (int i = 0; i < AURA_MAX; i++)
        Stats->Aura.Type[i].Active = true;
    
    // Needs reinitialization to apply new info
    Stats->NeedReinit = true;
};

// Modify the targeted monsters stats (mainly for debugging)
acscript void MonsterModStat(int Stat, int Value)
{
    // Move script to the targeted monster
    SetActivatorToTarget(Player.TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    switch (Stat - 1)
    {
    case STAT_STRENGTH:     Stats->Strength = Value;        break;
    case STAT_DEFENSE:      Stats->Defense = Value;         break;
    case STAT_VITALITY:     Stats->Vitality = Value;        break;
    case STAT_ENERGY:       Stats->Energy = Value;          break;
    case STAT_REGENERATION: Stats->Regeneration = Value;    break;
    case STAT_AGILITY:      Stats->Agility = Value;         break;
    case STAT_CAPACITY:     Stats->Capacity = Value;        break;
    case STAT_LUCK:         Stats->Luck = Value;            break;
    };
};

// Dump the targeted monster's stats to the console
acscript void MonsterDump()
{
    int PlayerNum = PlayerNumber();
    
    // Move script to the targeted monster
    SetActivatorToTarget(Player.TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // If you have no target, terminate
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        PrintError("You have no target");
        ActivatorSound("menu/error", 127);
        return;
    };
    
    Log("\ca===== MONSTER INFORMATION =====\n");
    Log(" Actor: %s\n", GetActorClass(0));
    Log(" Replacement Actor: %s\n", Stats->ReplaceActor);
    Log(" Position: %k, %k, %k\n", Stats->Position.X, Stats->Position.Y, Stats->Position.Z);
    Log(" Tag: %s\n", GetActorPropertyString(0, APROP_Nametag));
    Log(" Height: %k\n", GetActorPropertyFixed(0, APROP_Height));
    Log(" Radius: %k\n", GetActorPropertyFixed(0, APROP_Radius));
    Log(" Speed: %k\n", GetActorPropertyFixed(0, APROP_Speed));
    Log(" TID: %d\n", ActivatorTID());
    Log(" ID: %d\n", GetMonsterID(0));
    
    if (GetMonsterID(0) != 0)
    {
        Log("\cf===== MONSTER FLAGS =====\n");
        Log(" Init: %d\n", Stats->Init);
        Log(" Named: %d\n", Stats->Named);
        Log(" HealthBar: %d\n", Stats->HealthBar);
        Log(" RenderStyle: %d\n", Stats->RenderStyle);
        Log(" DRPG Flags: %d\n", Stats->Flags);
        Log(" Reinforcement: %d\n", Stats->Reinforcement);
        Log(" Assassination Target: %d\n", Stats->Target);
        Log(" MegaBoss: %d\n", Stats->MegaBoss);
        
        Log("\cd===== MONSTER STATS =====\n");
        Log(" Level: %d\n", Stats->Level);
        Log(" Threat: %d\n", Stats->Threat);
        Log(" Spawn Health: %d\n", Stats->SpawnHealth);
        Log(" Health Max: %d\n", Stats->HealthMax);
        Log(" Health Regenerated: %d\n", Stats->RegenHealth);
        Log(" Base Speed: %d\n", Stats->Speed);
        Log(" \cgStrength: %d\n", Stats->Strength);
        Log(" \cdDefense: %d\n", Stats->Defense);
        Log(" \caVitality: %d\n", Stats->Vitality);
        Log(" \cnEnergy: %d\n", Stats->Energy);
        Log(" \ctRegeneration: %d\n", Stats->Regeneration);
        Log(" \ciAgility: %d\n", Stats->Agility);
        Log(" \chCapacity: %d\n", Stats->Capacity);
        Log(" \ckLuck: %d\n", Stats->Luck);
        
        Log("\cd===== MONSTER AURAS =====\n");
        Log(" Time: %s\n", FormatTime(Stats->Aura.Time));
        for (int i = 0; i < AURA_MAX; i++) // TODO: Make this prettier
            if (Stats->Aura.Type[i].Active)
                Log(" Active: %d\n", i);
    };
};

// Damage the target
acscript void MonsterDamage(int Amount, int Type)
{
    SetActivatorToTarget(Player.TID);
    
    if (ActivatorTID() == Player.TID)
        return;
    
    DamageThing(Amount, Type);
};

// Apply stats to monsters
script void MonsterInitStats(int StatFlags)
{
    // Move Activator to whoever the player is targeting
    if (StatFlags & SF_PLAYERTARGET)
        SetActivatorToTarget(Player.TID);
    
    if (ClassifyActor(0) & ACTOR_WORLD)
        return; // The Monster Reducer can remove a monster before it attains stats, so if that happens, don't bother.
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    int MonsterLevel = Stats->Level;
    int MonsterThreat = Stats->Threat;
    fixed MonsterSpeed = Stats->Speed;
    int MonsterStrength = Stats->Strength;
    int MonsterDefense = Stats->Defense;
    int MonsterVitality = Stats->Vitality;
    int MonsterEnergy = Stats->Energy;
    int MonsterRegeneration = Stats->Regeneration;
    int MonsterAgility = Stats->Agility;
    int MonsterCapacity = Stats->Capacity;
    int MonsterLuck = Stats->Luck;
    int LevelType = GetCVar("drpg_monster_levels");
    fixed LevelWeight = GetCVarFixed("drpg_monster_level_weight");
    fixed MapWeight = GetCVarFixed("drpg_monster_map_weight");
    fixed RandomMinWeight = GetCVarFixed("drpg_monster_random_min_mult");
    fixed RandomMaxWeight = GetCVarFixed("drpg_monster_random_max_mult");
    int LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
    int NumPlayers;
    int[8] StatEffect;
    
    // Cap Level Number to 100
    if (LevelNum > 100)
        LevelNum = 100;
    
    // If the Arena is active, base the Monster Levels Map Number portion on the current wave
    if (InBase && ArenaActive)
        LevelNum = ArenaWave / 3;
    
    // Calculate Monster Level
    if (LevelType == 1 || LevelType == 3) // Player Level
        MonsterLevel += (int)((fixed)AveragePlayerLevel() * LevelWeight);
    if (LevelType == 2 || LevelType == 3) // Map Number
        MonsterLevel += (int)((fixed)LevelNum * MapWeight);
    
    // Randomization Weight
    if (RandomMinWeight > RandomMaxWeight)
        Log("\cgERROR: \c-Monster Random Min Multiplier cannot be above Monster Random Max Multiplier!\n")
    else
        MonsterLevel = (int)(MonsterLevel * RandomFixed(RandomMinWeight, RandomMaxWeight));
    
    // If the monster is friendly, it has the average level of all players in the game
    if (GetActorProperty(0, APROP_Friendly))
        MonsterLevel = AveragePlayerLevel();
    
    // Special case for Bosses
    if (Stats->Flags & MF_BOSS)
        MonsterLevel += (GameSkill() * 10);
    
    // Special case for Megabosses
    if (Stats->Flags & MF_MEGABOSS)
        MonsterLevel += ((1000 / MAX_PLAYERS) * PlayerCount());
    
    // Special case for Powersuit Mk. II
    if (GetActorClass(0) == "DRPGSuperPowerSuit")
        MonsterLevel = 1000;
    
    // Calculate the monster's cut and special stats
    if (GetCVar("drpg_monster_specialize"))
    {
        // [KS] Here's a fun and fast little way of doing it:
        
        // 2 specialized stats
        StatEffect[0] = 2;
        StatEffect[1] = 2;
        
        // 2 normal stats
        StatEffect[2] = 0;
        StatEffect[3] = 0;
        
        // 4 cut stats
        StatEffect[4] = 1;
        StatEffect[5] = 1;
        StatEffect[6] = 1;
        StatEffect[7] = 1;
        
        // And shuffle 'em up!
        for (int i = 0; i < STAT_MAX; i++)
        {
            int SwapWith = Random(0, STAT_MAX - 1);
            int Temp = StatEffect[i];
            
            StatEffect[i] = StatEffect[SwapWith];
            StatEffect[SwapWith] = Temp;
        };
    };
    
    // Calculate Monster Stats
    MonsterStrength = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
    MonsterDefense = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
    MonsterVitality = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
    MonsterEnergy = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
    MonsterRegeneration = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
    MonsterAgility = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
    MonsterCapacity = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
    MonsterLuck = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
    
    if (GetCVar("drpg_monster_specialize"))
    {
        // Cut Stats
        if (StatEffect[0] == 1) MonsterStrength /= 2;
        if (StatEffect[1] == 1) MonsterDefense /= 2;
        if (StatEffect[2] == 1) MonsterVitality /= 2;
        if (StatEffect[3] == 1) MonsterEnergy /= 2;
        if (StatEffect[4] == 1) MonsterRegeneration /= 2;
        if (StatEffect[5] == 1) MonsterAgility /= 2;
        if (StatEffect[6] == 1) MonsterCapacity /= 2;
        if (StatEffect[7] == 1) MonsterLuck /= 2;
        
        // Specialized Stats
        if (StatEffect[0] == 2) MonsterStrength *= Random(2, 4);
        if (StatEffect[1] == 2) MonsterDefense *= Random(2, 4);
        if (StatEffect[2] == 2) MonsterVitality *= Random(2, 4);
        if (StatEffect[3] == 2) MonsterEnergy *= Random(2, 4);
        if (StatEffect[4] == 2) MonsterRegeneration *= Random(2, 4);
        if (StatEffect[5] == 2) MonsterAgility *= Random(2, 4);
        if (StatEffect[6] == 2) MonsterCapacity *= Random(2, 4);
        if (StatEffect[7] == 2) MonsterLuck *= Random(2, 4);
    };
    
    // Map Event - RAINBOWS!
    if (CurrentLevel->Event == MAPEVENT_BONUS_RAINBOWS)
        MonsterCapacity *= Random(2, 4);
    
    // Apply Aura
    if (!GetActorProperty(0, APROP_Friendly) && !(Stats->Flags & MF_NOAURA) && !(Stats->Flags & MF_NOAURAGEN) && !StatFlags)
    {
        // 1st roll: Chance of having an aura at all
        bool HasAura = true;
        if (CurrentLevel->Event != MAPEVENT_ALLAURAS)
        {
            int AuraChance = 31 + ((GetCVar("drpg_aura_curve") * 100 / 97) + (MonsterLuck * 100 / 97));
            if (AuraChance < 0)    AuraChance = 0;
            if (AuraChance > 1000) AuraChance = 1000;
            AuraChance *= AuraChance;
            AuraChance /= 1000;
            HasAura = (Random(0, 1000) < AuraChance);
        };
        
        // 2nd roll: Number of auras to have
        int AuraRand = Random(MonsterEnergy / 10, 200);
        int AuraNumber = (AuraRand * AuraRand) / 4000;
        if (AuraNumber < 1) AuraNumber = 1;
        if (AuraNumber > AURA_MAX) AuraNumber = AURA_MAX;
        if (!HasAura) AuraNumber = 0;

        // Run through and decide on which Auras it should have
        while (AuraNumber > 0)
        {
            int AuraType = Random(0, AURA_MAX - 1);
            if (Stats->Aura.Type[AuraType].Active == true)
                continue;
            
            Stats->Aura.Type[AuraType].Active = true;
            AuraNumber--;
        };
        
        // Are You A Bad Enough Dude?
        if (GetCVar("drpg_monster_shadows"))
            for (int i = 0; i < AURA_MAX; i++)
                Stats->Aura.Type[i].Active = true;
    };
    
    // Apply the aura effects
    if (Stats->Aura.Type[AURA_RED].Active) // Red Aura - Strength
    {
        MonsterStrength *= 2;
        GiveInventory("DRPGRedAuraGiver", 1);
        MonsterDamageRetaliationHandler();
    };
    if (Stats->Aura.Type[AURA_GREEN].Active) // Green Aura - Defense
    {
        MonsterDefense *= 2;
        GiveInventory("DRPGGreenAuraGiver", 1);
    };
    if (Stats->Aura.Type[AURA_WHITE].Active) // White Aura - XP
    {
        MonsterLevel *= 2;
        GiveInventory("DRPGWhiteAuraGiver", 1);
        MonsterLevelupHandler();
    };
    if (Stats->Aura.Type[AURA_PINK].Active) // Pink Aura - Vitality
    {
        MonsterVitality *= 2;
        GiveInventory("DRPGPinkAuraGiver", 1);
        MonsterFellowResurrectionHandler();
    };
    if (Stats->Aura.Type[AURA_BLUE].Active) // Blue Aura - Energy
    {
        MonsterEnergy *= 2;
        GiveInventory("DRPGBlueAuraGiver", 1);
        MonsterEPDrainHandler();
    };
    if (Stats->Aura.Type[AURA_PURPLE].Active) // Purple Aura - Regeneration
        MonsterRegeneration *= 2;
    if (Stats->Aura.Type[AURA_ORANGE].Active) // Orange Aura - Agility
    {
        MonsterAgility *= 2;
        GiveInventory("DRPGOrangeAuraGiver", 1);
        MonsterEpicVisitTimeHandler();
    };
    if (Stats->Aura.Type[AURA_DARKBLUE].Active) // Dark Blue Aura - Capacity
    {
        MonsterCapacity *= 2;
        MonsterAmmoDrainHandler();
    };
    if (Stats->Aura.Type[AURA_YELLOW].Active) // Yellow Aura - Luck
    {
        MonsterLuck *= 2;
        MonsterMoneyDrainHandler();
    };
    
    // Calculate Aura time
    Stats->Aura.Time = (30 * 35) + (int)((fixed)MonsterEnergy * 0.57) * 35;
    
    // Cap Level and Stats
    CapMonsterStats(Stats);
    
    // We need to make sure we only pass the speed to the monster if it's being initially created
    MonsterSpeed = GetActorPropertyFixed(0, APROP_Speed);
    
    // Apply the stats to the monster
    Stats->Level = MonsterLevel;
    Stats->Speed = MonsterSpeed;
    Stats->Strength = MonsterStrength;
    Stats->Defense = MonsterDefense;
    Stats->Vitality = MonsterVitality;
    Stats->Energy = MonsterEnergy;
    Stats->Regeneration = MonsterRegeneration;
    Stats->Agility = MonsterAgility;
    Stats->Capacity = MonsterCapacity;
    Stats->Luck = MonsterLuck;
    
    // [KS] We only need to do a health check here since the other checks are handled below.
    // Calculate Health
    Stats->HealthMax = CalculateMonsterMaxHealth(Stats);
    SetActorProperty(0, APROP_Health, Stats->HealthMax);
    
    // Generate Name
    if (!Stats->Named && (Stats->Flags & MF_MEGABOSS || Stats->Flags & MF_NAMEGEN || MonsterHasShadowAura(Stats)))
    {
        SetActorPropertyString(0, APROP_Nametag, GenerateName(GetActorClass(0), GetActorPropertyString(0, APROP_Nametag)));
        Stats->Named = true;
    };
    
    // Reinitialize the stats handler if recreation has occurred
    if (StatFlags & SF_RECREATE)
    {
        Stats->NeedReinit = false;
        MonsterStatsHandler();
    };
};

script void MonsterStatsHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    int OldStrength;
    int OldDefense;
    int OldCapacity;
    int OldVitality;
    int OldAgility;
    int OldRegeneration;
    int OldEnergy;
    int OldLuck;
    bool StatsChanged;
    
    Start:
    
    if (GetActorProperty(0, APROP_Health) <= 0)
    {
        if (OldStrength)
        {
            OldStrength = 0;
            OldDefense = 0;
            OldCapacity = 0;
            OldVitality = 0;
            OldAgility = 0;
            OldRegeneration = 0;
            OldEnergy = 0;
            OldLuck = 0;
        };
        Delay(35);
        goto Start;
    };

    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    if (Stats->NeedReinit)
    {
        MonsterInitStats(SF_RECREATE);
        return;
    };
    
    /* Monster is no longer friendly, remove their summon bonuses and species
    // This causes issues with infighting and I don't remember why I did this in the first place
    // Just comment it out and leave it alone for now
    if (!GetActorProperty(0, APROP_Friendly))
    {
        GiveInventory("DRPGFriendlyRemover", 1);
        SetActorPropertyString(0, APROP_Species, "");
    }; */
    
    // Levelup handling via White Aura radius
    if (CheckInventory("DRPGMonsterLevelup"))
        MonsterLevelup(Stats);
    
    // Cap Level and Stats
    CapMonsterStats(Stats);
    
    // Strength
    if (Stats->Strength != OldStrength)
    {
        StatsChanged = true;
        
        SetActorPropertyFixed(0, APROP_DamageMultiplier, 1.0 + ((fixed)(Stats->Strength * (fixed)GameSkill()) / 100.0));
        OldStrength = Stats->Strength;
    };
    
    // Defense
    if (Stats->Defense != OldDefense)
    {
        StatsChanged = true;
        
        SetActorPropertyFixed(0, APROP_DamageFactor, 1.0 - (0.09 * ((fixed)Stats->Defense / 100.0)));
        OldDefense = Stats->Defense;
    };
    
    // Capacity
    if (Stats->Capacity != OldCapacity)
    {
        StatsChanged = true;
        
        int StolenCredits = 0;
        if (CheckInventory("DRPGCredits") > OldCapacity)
             StolenCredits = CheckInventory("DRPGCredits") - OldCapacity;
        
        SetInventory("DRPGCredits", Stats->Capacity + StolenCredits);
        OldCapacity = Stats->Capacity;
    };
    
    // Agility
    if (Stats->Agility != OldAgility)
    {
        StatsChanged = true;
        
        SetActorPropertyFixed(0, APROP_Speed, CalculateMonsterSpeed(Stats));
        OldAgility = Stats->Agility;
    };
    
    // Vitality
    if (Stats->Vitality != OldVitality)
    {
        StatsChanged = true;
        
        int HealthPercentage = 100;
        if (Stats->HealthMax > 0)
            HealthPercentage = (long long)GetActorProperty(0, APROP_Health) * 100 / Stats->HealthMax;
        Stats->HealthMax = CalculateMonsterMaxHealth(Stats);
        
        if (OldVitality == 0)
        {
            // This will trigger if the monster was previously dead and revived, so heal up fully
            SetActorProperty(0, APROP_Health, Stats->HealthMax);
        }
        else
        {
            SetActorProperty(0, APROP_Health, (long long)Stats->HealthMax * HealthPercentage / 100);
        };
        
        OldVitality = Stats->Vitality;
    };
    
    // Nothing much to do for these
    
    // Regeneration
    if (Stats->Regeneration != OldRegeneration)
    {
        StatsChanged = true;
        OldRegeneration = Stats->Regeneration;
    };
    
    // Energy
    if (Stats->Energy != OldEnergy)
    {
        StatsChanged = true;
        OldEnergy = Stats->Energy;
    };
    
    // Luck
    if (Stats->Luck != OldLuck)
    {
        StatsChanged = true;
        OldLuck = Stats->Luck;
    };
    
    if (StatsChanged)
    {
        // Re-calculate the monster's threat level
        Stats->Threat = CalculateMonsterThreatLevel(Stats);
        
        StatsChanged = false;
    };
    
    Delay(4);
    goto Start;
};

script void MonsterAuraDisplayHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    bool VisibleToPlayers;
    
    Start:
    
    if (GetActorProperty(0, APROP_Health) <= 0)
    {
        Delay(35);
        goto Start;
    };

    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    if (GetCVar("drpg_simple_auras"))
        VisibleToPlayers = true
    else
    {
        VisibleToPlayers = false;
        
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            if (CheckSight(Players(i).TID, 0, CSF_NOBLOCKALL))
            {
                VisibleToPlayers = true;
                break;
            };
        };
    };
    
    if (!VisibleToPlayers)
    {
        Delay(4);
        goto Start;
    };
    
    // Spawn Auras
    if (MonsterHasAura(Stats) || (GetActorProperty(0, APROP_Friendly) && !InBase))
        SpawnAuras(0, false);
    
    // Shadow Aura Effects
    if (MonsterHasShadowAura(Stats))
    {
        if (GetActorLightLevel(0) < 192)
            SetActorProperty(0, APROP_RenderStyle, STYLE_Fuzzy)
        else
            SetActorProperty(0, APROP_RenderStyle, Stats->RenderStyle);
    };
    
    // Spawn Assassination Target
    if (Stats->Target > 0)
        SpawnForced("DRPGAssassinationIcon", GetActorX(0), GetActorY(0), GetActorZ(0) + GetActorPropertyFixed(0, APROP_Height) + 16.0 + (Sin(Timer() / 64.0) * 8.0), 0, 0);
    
    if (ClassifyActor(0) & ACTOR_DEAD)
        return;
    
    Delay(1);
    goto Start;
};

script void MonsterLevelupHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    int Energy;
    int DelayTime;
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    
    // Calculate the Delay Time
    Energy = Stats->Energy;
    DelayTime = 35 * (int)((60.0 - ((fixed)Energy / 16.75)));
    if (DelayTime < 35)
        DelayTime = 35;
    Delay(DelayTime);
    
    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    if (ClassifyActor(0) & ACTOR_DEAD)
    {
        Delay(35);
        goto Start;
    };
    
    // Loop back to the top if the monster is max level
    if (Stats->Level >= 1000)
        goto Start;
    
    // White Aura monsters levelup monsters near them
    if (Stats->Aura.Type[AURA_WHITE].Active)
        for (int i = 0; i < MAX_PLAYERS; i++) // LOS Check on players
            if (CheckSight(0, Players(i).TID, 0))
            {
                if (!PlayerInGame(i)) continue;
                
                GiveInventory("DRPGMonsterLevelupGiver", 1);
                break;
            };
    
    // Return here if the White Aura is no longer active
    if (!Stats->Aura.Type[AURA_WHITE].Active)
        return;
    
    goto Start;
};

script void MonsterEPDrainHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    
    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    if (ClassifyActor(0) & ACTOR_DEAD)
    {
        Delay(35);
        goto Start;
    };
    
    if (!Stats->Aura.Type[AURA_BLUE].Active)
    {
        Delay(35);
        goto Start;
    };
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        // Stupid hack to prevent stealing from triggering at the beginning of a level
        if (Timer() <= 4) break;
        
        if (!PlayerInGame(i)) continue;
        
        if (Distance(0, Players(i).TID) < Stats->Radius * GameSkill() * 4 + Stats->Radius && CheckSight(0, Players(i).TID, 0) && Players(i).EP > 0)
        {
            // Continue if this player is immune to stealing
            if ((Players(i).Aura.Type[AURA_PINK].Active && Players(i).Aura.Type[AURA_PINK].Level >= 3) || Players(i).SoulActive[SOUL_PINK]) continue;
            
            int Previous = Players(i).EP;
            
            // [KS] Okay, so at natural max, a player has 2000 EP. We want that to drain in 20 seconds rather than just instantly.
            // This should also make specialized Energy auras more tolerable in general.
            int DrainAmount = Stats->Energy / 10;
            if (DrainAmount < 1)
                DrainAmount = 1;
            
            Players(i).EP -= DrainAmount;
            
            if (Players(i).EP < 0)
                Players(i).EP = 0;
            
            if (Players(i).EP < Previous)
            {
                Popoff(0, Previous - Players(i).EP, DNUM_EPGAIN, "DRPGDigit", true);
                
                int OrigTID = ActivatorTID();
                int NewTID = UniqueTID(0, 0);
                Thing_ChangeTID(0, NewTID);
                SetActivator(Players(i).TID);
                FadeRange(64, 128, 128, 0.5, 64, 128, 128, 0.0, 0.5);
                ActivatorSound("drain/ep", 32);
                SetActivator(NewTID);
                Thing_ChangeTID(0, OrigTID);
            };
        };
    };
    
    Delay(35);
    
    goto Start;
};

script void MonsterRegenerationHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    
    if (GetActorProperty(0, APROP_Health) <= 0)
    {
        Delay(35);
        goto Start;
    };

    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    long long RegenAmount = (long long)Stats->HealthMax * (long long)Stats->Regeneration;
    
    if (Stats->RegenHealth >= Stats->HealthMax * 10)
        RegenAmount /= 10000
    else
        RegenAmount /= 1000;
    
    if (RegenAmount > INT_MAX)
        RegenAmount = INT_MAX;
    
    SetActorProperty(0, APROP_Health, GetActorProperty(0, APROP_Health) + RegenAmount);
    Stats->RegenHealth += RegenAmount;
    
    if (Stats->Aura.Type[AURA_PURPLE].Active)
        GiveInventory("DRPGMonsterRadiusHealer", 1);
    
    // Prevent going over 100%
    if (GetActorProperty(0, APROP_Health) > Stats->HealthMax)
        SetActorProperty(0, APROP_Health, Stats->HealthMax);
    
    Delay(35 * (Stats->Aura.Type[AURA_PURPLE].Active ? 10 : 30));
    goto Start;
};

acscript void MonsterRegenHealer()
{
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    int Health = GetActorProperty(0, APROP_Health);
    
    int HealAmount = Stats->HealthMax / 10;
    if (HealAmount < 1)
        HealAmount = 1;
    
    if (Health + HealAmount > Stats->HealthMax)
        HealAmount = Stats->HealthMax - Health;
    
    if (HealAmount <= 0)
        return;
    
    GiveInventory("DRPGMonsterHealEffect", 1);
    SetActorProperty(0, APROP_Health, Health + HealAmount);
};

script void MonsterDamageRetaliationHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    int Health = GetActorProperty(0, APROP_Health);
    int OldHealth = GetActorProperty(0, APROP_Health);
    
    Start:
    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    if (ClassifyActor(0) & ACTOR_DEAD)
    {
        Delay(35);
        goto Start;
    };
    
    if (!Stats->Aura.Type[AURA_RED].Active)
    {
        Delay(35);
        goto Start;
    };
    
    Health = GetActorProperty(0, APROP_Health);
    
    if (Health < OldHealth)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i)) continue;
            if (!CheckSight(0, Players(i).TID, 0))  continue;
            
            fixed CurseChance = ((fixed)Stats->Strength / 10.0) - (Distance(0, Players(i).TID) / 5.12);
            
            if (CurseChance <= 0)
                continue;
            
            if (CurseChance >= 100.0 || RandomFixed(0.0, 100.0) <= CurseChance)
            {
                int Intensity = ((fixed)Stats->Strength / 200.0) - (Distance(0, Players(i).TID) / 102.4);
                if (Intensity < 1) Intensity = 1;
                int OrigTID = ActivatorTID();
                int NewTID = UniqueTID(0, 0);
                Thing_ChangeTID(0, NewTID);
                SetActivator(Players(i).TID);
                FadeRange(255, 0, 0, 0.5, 255, 0, 0, 0.0, 0.5);
                TryStatusEffect(SE_CURSE, Random(30,90), Intensity);
                SetActivator(NewTID);
                Thing_ChangeTID(0, OrigTID);
            };
        };
    };
    
    if (CheckInventory("DRPGMonsterEPAttacked"))
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i)) continue;
            if (!CheckSight(0, Players(i).TID, 0)) continue;
            
            fixed SilenceChance = (Stats->Strength / 5) - (Distance(0, Players(i).TID) / 10.24);
            
            if (SilenceChance <= 0)
                continue;
            
            if (SilenceChance >= 100.0 || RandomFixed(0.0, 100.0) <= SilenceChance)
            {
                int Intensity = (Stats->Strength / 200) - (Distance(0, Players(i).TID) / 102.4);
                if (Intensity < 1) Intensity = 1;
                int OrigTID = ActivatorTID();
                int NewTID = UniqueTID(0, 0);
                Thing_ChangeTID(0, NewTID);
                SetActivator(Players(i).TID);
                FadeRange(255, 0, 0, 0.5, 255, 0, 0, 0.0, 0.5);
                TryStatusEffect(SE_SILENCE, Random(30,90), Intensity);
                SetActivator(NewTID);
                Thing_ChangeTID(0, OrigTID);
            };
        };
        
        SetInventory("DRPGMonsterEPAttacked", 0);
    };
    
    Delay(4);
    
    OldHealth = Health;
    
    goto Start;
};

script void MonsterMoneyDrainHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    if (ClassifyActor(0) & ACTOR_DEAD)
    {
        Delay(35);
        goto Start;
    };
    
    if (!Stats->Aura.Type[AURA_YELLOW].Active)
    {
        Delay(35);
        goto Start;
    };
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        // Stupid hack to prevent stealing from triggering at the beginning of a level
        if (Timer() <= 4) break;
        
        if (!PlayerInGame(i)) continue;
        
        if (Distance(0, Players(i).TID) < Stats->Radius * GameSkill() * 4 + Stats->Radius && CheckSight(0, Players(i).TID, 0))
        {
            // Continue if this player is immune to stealing
            if ((Players(i).Aura.Type[AURA_PINK].Active && Players(i).Aura.Type[AURA_PINK].Level >= 3) || Players(i).SoulActive[SOUL_PINK]) continue;
            
            int Previous = CheckActorInventory(Players(i).TID, "DRPGCredits");
            int OrigTID = ActivatorTID();
            int NewTID = UniqueTID(0, 0);
            Thing_ChangeTID(0, NewTID);
            TakeActorInventory(Players(i).TID, "DRPGCredits", Stats->Luck);
            GiveInventory("DRPGCredits", Stats->Luck);
            SetActivator(Players(i).TID);
            FadeRange(255, 255, 0, 0.5, 255, 255, 0, 0.0, 0.5);
            ActivatorSound("drain/money", 32);
            SetActivator(NewTID);
            Thing_ChangeTID(0, OrigTID);
            
            if (CheckActorInventory(Players(i).TID, "DRPGCredits") < Previous)
                Popoff(0, Previous - CheckActorInventory(Players(i).TID, "DRPGCredits"), DNUM_CREDGAIN, "DRPGDIGIT", true);
        };
    };
    
    Delay(35);
    
    goto Start;
};

script void MonsterAmmoDrainHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    if (ClassifyActor(0) & ACTOR_DEAD)
    {
        Delay(35);
        goto Start;
    };
    
    if (!Stats->Aura.Type[AURA_DARKBLUE].Active)
    {
        Delay(35);
        goto Start;
    };
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        // Stupid hack to prevent stealing from triggering at the beginning of a level
        if (Timer() <= 4) break;
        
        if (!PlayerInGame(i)) continue;
        
        if (Distance(0, Players(i).TID) < Stats->Radius * GameSkill() * 4 + Stats->Radius && CheckSight(0, Players(i).TID, 0))
        {
            // Continue if this player is immune to stealing
            if ((Players(i).Aura.Type[AURA_PINK].Active && Players(i).Aura.Type[AURA_PINK].Level >= 3) || Players(i).SoulActive[SOUL_PINK]) continue;
            
            // [KS] We'll give the player 30 seconds of ammo if they were full at stat max.
            int ClipSteal = (int)((fixed)Stats->Capacity / 7.5);
            int ShellSteal = (int)((fixed)Stats->Capacity / 30);
            int RocketSteal = (int)((fixed)Stats->Capacity / 30);
            int CellSteal = (int)((fixed)Stats->Capacity / 5);
            
            if (ClipSteal < 2) ClipSteal = 2;
            if (ShellSteal < 1) ShellSteal = 1;
            if (RocketSteal < 1) RocketSteal = 1;
            if (CellSteal < 3) CellSteal = 3;
            
            if (CheckActorInventory(Players(i).TID, "Clip") >= ClipSteal)
            {
                TakeActorInventory(Players(i).TID, "Clip",       ClipSteal);
                GiveInventory("Clip",       ClipSteal);
            };
            if (CheckActorInventory(Players(i).TID, "Shell") >= ShellSteal)
            {
                TakeActorInventory(Players(i).TID, "Shell",      ShellSteal);
                GiveInventory("Shell",      ShellSteal);
            };
            if (CheckActorInventory(Players(i).TID, "RocketAmmo") >= RocketSteal)
            {
                TakeActorInventory(Players(i).TID, "RocketAmmo", RocketSteal);
                GiveInventory("RocketAmmo", RocketSteal);
            };
            if (CheckActorInventory(Players(i).TID, "Cell") >= CellSteal)
            {
                TakeActorInventory(Players(i).TID, "Cell",       CellSteal);
                GiveInventory("Cell",       CellSteal);
            };
            
            int OrigTID = ActivatorTID();
            int NewTID = UniqueTID(0, 0);
            Thing_ChangeTID(0, NewTID);
            SetActivator(Players(i).TID);
            FadeRange(0, 0, 255, 0.5, 0, 0, 255, 0.0, 0.5);
            ActivatorSound("drain/ammo", 32);
            SetActivator(NewTID);
            Thing_ChangeTID(0, OrigTID);
        };
    };
    
    Delay(35);
    
    goto Start;
};

script void MonsterFellowResurrectionHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    if (ClassifyActor(0) & ACTOR_DEAD)
    {
        Delay(35);
        goto Start;
    };
    
    if (!Stats->Aura.Type[AURA_PINK].Active)
    {
        Delay(35);
        goto Start;
    };
    
    GiveInventory("DRPGMonsterRadiusResurrection", 1);
    
    Delay(35 * (30 - (20 * Stats->Vitality / 1000)));
    
    goto Start;
};

script void MonsterEpicVisitTimeHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    if (ClassifyActor(0) & ACTOR_WORLD)
        return;
    
    if (ClassifyActor(0) & ACTOR_DEAD)
    {
        Delay(35);
        goto Start;
    };
    
    if (!Stats->Aura.Type[AURA_ORANGE].Active)
    {
        Delay(35);
        goto Start;
    };
    
    fixed TeleportDistance = 0;
    int TeleportPlayer = -1;
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i)) continue;
        if (!CheckSight(0, Players(i).TID, 0)) continue;
        if (Distance(0, Players(i).TID) <= TeleportDistance) continue;
        
        TeleportDistance = Distance(0, Players(i).TID);
        TeleportPlayer = i;
    };
    
    fixed TeleportChance = ((fixed)TeleportDistance / 40.96) + (25.0 * (Stats->Agility / 1000.0)) ;
    
    if (RandomFixed(0.0, 100.0) <= TeleportChance)
    {
        int TeleportSpotTID = UniqueTID();
        int TargetPlayerTID = Players(TeleportPlayer).TID;
        
        bool Success = false;
        fixed TeleportAngle;
        fixed TeleportDistance;
        fixed X, Y, Z, Angle;
        
        for (int i = 0; i < 10; i++)
        {
            fixed TeleportAngle = RandomFixed(0, 1);
            fixed TeleportDistance = RandomFixed(128, 384);
            
            X = GetActorX(TargetPlayerTID) + (Cos(TeleportAngle) * TeleportDistance);
            Y = GetActorY(TargetPlayerTID) + (Sin(TeleportAngle) * TeleportDistance);
            Z = GetActorZ(TargetPlayerTID);
            Angle = TeleportAngle + 0.5;
            Angle %= 1.0;
            
            Success = Spawn("MapSpot", X, Y, Z, TeleportSpotTID, Angle);
            if (Success && !SetActorPosition(TeleportSpotTID, GetActorX(TeleportSpotTID), GetActorY(TeleportSpotTID), GetActorFloorZ(TeleportSpotTID), false)) Success = false;
            if (Success && !CheckSight(TargetPlayerTID, TeleportSpotTID, 0)) Success = false;
            if (Success)
                break;
        };
        
        if (Success)
        {
            // Surprise!!
            SpawnSpotFacingForced("TeleportFog", 0, 0);
            SetActorPosition(0, GetActorX(TeleportSpotTID), GetActorY(TeleportSpotTID), GetActorZ(TeleportSpotTID), false);
            SetActorAngle(0, Angle);
            SpawnSpotFacingForced("TeleportFog", 0, 0);
            Thing_Remove(TeleportSpotTID);
        };
    };
    
    Delay(35 * 10);
    
    goto Start;
};

script void MonsterDeathCheck()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    Delay(1);
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];

    Start:
    
    if (ClassifyActor(0) & ACTOR_WORLD)
        goto Disappeared;
    
    if (GetActorProperty(0, APROP_Health) > 0)
    {
        Delay(4);
        goto Start;
    };

    MonsterDeath();
    
    PostDeathWait:
    
    Delay(35);
    
    if (ClassifyActor(0) & ACTOR_WORLD)
        goto Disappeared;
    
    if (GetActorProperty(0, APROP_Health) > 0)
        goto Start;
    
    goto PostDeathWait;
    
    Disappeared:
    
    Stats->Init = false; // Mark as unused
};

script void MonsterDeath()
{
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    int Killer = WhoKilledMe();
    fixed XPAmount = Random(GetActorProperty(0, APROP_SpawnHealth) / 2.0, GetActorProperty(0, APROP_SpawnHealth)) * (1.0 + (fixed)Stats->Threat * 0.3);
    int RankAmount = GetActorProperty(0, APROP_SpawnHealth) * (1 + (Stats->Threat - (Stats->Threat > 0 ? 1 : 0)));
    int DropMod = Stats->Luck * 0.256;
    int DropAmount = (int)(1.0 + ((fixed)Stats->Luck / 500.0));
    
    // Always drop at least one item
    if (DropAmount < 1)
        DropAmount = 1;
    
    // Prevent Drop Mod from overflowing
    if (DropMod > 256)
        DropMod = 256;
    
    // Aura-Based XP/Rank Modifiers
    if (MonsterHasShadowAura(Stats))
    {
        XPAmount *= 2;
        RankAmount *= 4;
    }
    else if (Stats->Aura.Type[AURA_WHITE].Active)
        XPAmount *= 2;
    
    if (Players(Killer).Shield.Accessory)
    {
        switch (Players(Killer).Shield.Accessory->PassiveEffect)
        {
        case SHIELD_PASS_KILLSCHARGE:
            AddRemoteShield(Players(Killer).TID, Stats->HealthMax / 10);
            break;
        case SHIELD_PASS_BLOODYSHIELDSOREAL:
            Players(Killer).Shield.AccessoryBattery = 35 * 3;
            break;
        };
    };
    
    // Credit Rain
    if (Killer > -1 && (Players(Killer).Luck >= 100 || CurrentLevel->Event == MAPEVENT_BONUS_RAINBOWS) && Random(1, 256) == 1)
    {
        fixed Z = GetActorCeilingZ(Players(Killer).TID) - GetActorPropertyFixed(Players(Killer).TID, APROP_Height);
        fixed Radius = GetActorPropertyFixed(Players(Killer).TID, APROP_Radius);
        
        ThingSound(Players(Killer).TID, "credits/payout", 127);
        Log("\cdLUDICROUS CREDITS!\n");
        
        for (int i = 0; i < 100; i++)
        {
            int CreditType = Random(1, 6);
            str CreditName;
            
            switch (CreditType)
            {
            case 1: CreditName = "DRPGCredits1";    break;
            case 2: CreditName = "DRPGCredits5";    break;
            case 3: CreditName = "DRPGCredits10";   break;
            case 4: CreditName = "DRPGCredits20";   break;
            case 5: CreditName = "DRPGCredits50";   break;
            case 6: CreditName = "DRPGCredits100";  break;
            };
            
            DropMonsterItem(Killer, Players(Killer).TID, CreditName, 256, RandomFixed(-Radius, Radius), RandomFixed(-Radius, Radius), Z);
            Delay(1);
        };
    };
    
    // Add XP/Rank
    if (!(Stats->Flags & MF_NOXP) && !GetActorProperty(0, APROP_Friendly))
    {
        // XP modifications based on level and skill
        if (GetCVar("drpg_xp_monsterlevel")) XPAmount *= 1.0 + ((fixed)Stats->Level / 100.0);
        if (GetCVar("drpg_xp_skilllevel")) XPAmount *= 1.0 - (0.15 * (fixed)GameSkill());
        
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i)) continue;
            
            if (Killer == i)
            {
                AddXP(i, (int)XPAmount, RankAmount, false);
                if (GetCVar("drpg_levelup_natural"))
                {
                    fixed Scale = GetCVarFixed("drpg_strength_scalexp");
                    if (GetCVar("drpg_allow_spec"))
                    {
                        if (GetCVar("drpg_character_spec") == 1)
                            Scale *= 2;
                    };
                    Players(i).StrengthXP += (int)(XPAmount * Scale);
                };
            }
            else
                AddXP(i, (int)XPAmount, RankAmount, true);
        };
    };
    
    // Add a kill to the pay kills
    if (!(Stats->Flags & MF_NOPAYKILL) && Killer > -1)
    {
        if (Player.Shield.Accessory && Players(Killer).Shield.Accessory->PassiveEffect == SHIELD_PASS_EPICMEGACASH && Players(Killer).Shield.Active)
            Players(Killer).PayKills += 3
        else if (Stats->Flags & MF_BOSS)
            Players(Killer).PayKills += 4
        else if (Stats->Flags & MF_MEGABOSS)
            Players(Killer).PayKills += 8
        else
            Players(Killer).PayKills++;
    };
    
    // Mission Handling
    MissionDeathCheck(Killer, Stats);
    
    // SHOTGUNS!
    if (GetCVar("drpg_shotguns"))
        DropMonsterItem(Killer, 0, "DRPGShotSpawn", 1, 256);
    
    // Drops
    if (!(Stats->Flags & MF_NODROPS) && !GetActorProperty(0, APROP_Friendly) && !GetCVar("drpg_monster_shadows"))
    {
        for (int i = 1; i <= DropAmount; i++)
        {
            // Each Aura will guarantee a rare vial drop
            for (int j = 0; j < AURA_MAX; j++)
                if (Stats->Aura.Type[j].Active)
                    DropMonsterItem(Killer, 0, "DRPGVialDropperRare", 256);
            
            // Aura Drops
            if (Stats->Aura.Type[AURA_RED].Active) // Red Aura - Strength
            {
                DropMonsterItem(Killer, 0, "DRPGWeaponDropper", 128 + DropMod);
                DropMonsterItem(Killer, 0, "DRPGVialStrength", 256);
            };
            if (Stats->Aura.Type[AURA_GREEN].Active) // Green Aura - Defense
            {
                DropMonsterItem(Killer, 0, "DRPGArmorDropper", 128 + DropMod);
                DropMonsterItem(Killer, 0, "DRPGVialDefense", 256);
            };
            if (Stats->Aura.Type[AURA_PINK].Active) // Pink Aura - Vitality
            {
                DropMonsterItem(Killer, 0, "DRPGHealthDropper", 128 + DropMod);
                DropMonsterItem(Killer, 0, "DRPGVialVitality", 256);
            };
            if (Stats->Aura.Type[AURA_BLUE].Active) // Blue Aura - Energy
            {
                DropMonsterItem(Killer, 0, "DRPGEPCapsule", 128 + DropMod);
                DropMonsterItem(Killer, 0, "DRPGBigEPCapsule", 64 + DropMod);
                DropMonsterItem(Killer, 0, "DRPGVialEnergy", 256);
            };
            if (Stats->Aura.Type[AURA_PURPLE].Active) // Purple Aura - Regeneration
            {
                DropMonsterItem(Killer, 0, "DRPGRegenSphere", 128 + DropMod);
                DropMonsterItem(Killer, 0, "DRPGVialRegeneration", 256);
            };
            if (Stats->Aura.Type[AURA_ORANGE].Active) // Orange Aura - Agility
            {
                DropMonsterItem(Killer, 0, "DRPGTimeSphere", 64 + (DropMod / 2));
                DropMonsterItem(Killer, 0, "DRPGVialAgility", 256);
            };
            if (Stats->Aura.Type[AURA_DARKBLUE].Active) // Dark Blue Aura - Capacity
            {
                DropMonsterItem(Killer, 0, "DRPGAmmoDropper", 128 + DropMod);
                if (CompatMode == COMPAT_DRLA)
                    DropMonsterItem(Killer, 0, "RLModpackSpawner", 128 + DropMod);
                DropMonsterItem(Killer, 0, "DRPGVialCapacity", 256);
            };
            if (Stats->Aura.Type[AURA_YELLOW].Active) // Yellow Aura - Luck
            {
                DropMonsterItem(Killer, 0, "DRPGChipDropper", 255);
                DropMonsterItem(Killer, 0, "DRPGVialLuck", 256);
            };
            
            // Luck-based Drops
            if (Killer > -1 && !(Stats->Flags & MF_MEGABOSS))
            {
                if (Players(Killer).HealthDrop && RandomFixed(0.0, 100.0) < Players(Killer).HealthChance)    DropMonsterItem(Killer, 0, "DRPGHealthDropper", 256);
                if (Players(Killer).EPDrop && RandomFixed(0.0, 100.0) < Players(Killer).EPChance)            DropMonsterItem(Killer, 0, "DRPGEPCapsule", 256);
                if (Players(Killer).ArmorDrop && RandomFixed(0.0, 100.0) < Players(Killer).ArmorChance)      DropMonsterItem(Killer, 0, "DRPGArmorDropper", 256);
                if (Players(Killer).WeaponDrop && RandomFixed(0.0, 100.0) < Players(Killer).WeaponChance)    DropMonsterItem(Killer, 0, "DRPGWeaponDropper", 256);
                if (Players(Killer).PowerupDrop && RandomFixed(0.0, 100.0) < Players(Killer).PowerupChance)  DropMonsterItem(Killer, 0, "DRPGPowerupDropper", 256);
                if (Players(Killer).StimDrop && RandomFixed(0.0, 100.0) < Players(Killer).StimChance)        DropMonsterItem(Killer, 0, "DRPGVialDropperRare", 256);
                if (Players(Killer).ModuleDrop && RandomFixed(0.0, 100.0) < Players(Killer).ModuleChance)    DropMonsterItem(Killer, 0, "DRPGModuleDropper", 256);
                if (Players(Killer).ShieldDrop && RandomFixed(0.0, 100.0) < Players(Killer).ShieldChance)    DropMonsterItem(Killer, 0, "DRPGShieldDropper", 256);
                if (Players(Killer).AugDrop && RandomFixed(0.0, 100.0) < Players(Killer).AugChance)          DropMonsterItem(Killer, 0, "DRPGAugDropper", 256);
            };
            
            Delay(1);
        };
        
        // Boss Drops
        if (Stats->Flags & MF_BOSS)
        {
            DropMonsterItem(Killer, 0, "DRPGCredits1000", 256);
            DropMonsterItem(Killer, 0, "DRPGSoulsphereRandomizer", 256);
            DropMonsterItem(Killer, 0, "DRPGContinue", 128 + DropMod);
            DropMonsterItem(Killer, 0, "DRPGModuleDropper", 256 + DropMod);
            DropMonsterItem(Killer, 0, "DRPGAugDropper", 128 + DropMod);
            DropMonsterItem(Killer, 0, "DRPGShieldDropper", 128 + DropMod);
            DropMonsterItem(Killer, 0, "DRPGUACCard", (128 + DropMod) / (Players(Killer).ShopCard + 1));
            DropMonsterItem(Killer, 0, "DRPGImmunityCrystal", (DropMod / 8) + 1);
        };
        
        // Megaboss Drops
        if (Stats->Flags & MF_MEGABOSS)
        {
            AmbientSound("megaboss/lootsplosion", 127);
            Delay(35 * 2.25); // Just long enough to sync up with the sound nicely
            
            // LOOTSPLOOOOOOOOOOOOOSIIIOOOOOOOOOOOOOONNNNNN
            int Rolls = 200;
            while (Rolls--)
            {
                DropMonsterItem(Killer, 0, "DRPGCredits1000", 256, 0, 0, 0, 16, 16, Random(8, 16));
                for (int i = 0; i < PlayerCount(); i++)
                    DropMonsterItem(Killer, 0, "DRPGGenericBossDropper", 256, 0, 0, 0, 16, 16, Random(8, 16));
                if ((Rolls % 5) == 0)
                    Delay(1);
            };
            
            DropMonsterItem(Killer, 0, "DRPGDiamondUACCard", 256);
        };
    };
    
    // Drop Radiation Suits during the Environmental Hazard event
    if (!(Stats->Flags & MF_NODROPS) && !GetActorProperty(0, APROP_Friendly) && CheckInventory("DRPGMonsterRadSuit"))
        DropMonsterItem(Killer, 0, "RadSuit", 256);
    
    // Drop Nuke Keys during the Thermonuclear Bomb Map Event
    if (!(Stats->Flags & MF_NODROPS) && !GetActorProperty(0, APROP_Friendly) && CurrentLevel->Event == MAPEVENT_NUCLEARBOMB && (Random(1, 2) == 1 || Stats->Flags & MF_BOSS || Stats->Flags & MF_MEGABOSS))
        DropMonsterItem(Killer, 0, StrParam("DRPGNukeKey%d\n", Random(1, MAX_NUKE_KEYS)), 256);
    
    // Drop Generator Power Cells during the Low Power Event
    if (!(Stats->Flags & MF_NODROPS) && !GetActorProperty(0, APROP_Friendly) && CurrentLevel->Event == MAPEVENT_LOWPOWER)
        if (Random(1, CurrentLevel->MaxTotalMonsters / 4) == 1)
            DropMonsterItem(Killer, 0, "DRPGGeneratorCell", 256)
        else
            DropMonsterItem(Killer, 0, "DRPGGeneratorCellDead", 128);
    
    // Drop Credits
    if (!(Stats->Flags & MF_NODROPS) && CheckInventory("DRPGCredits") > 0)
    {
        fixed LuckMult = 1.0 + ((fixed)Players(Killer).Luck / 100.0);
        int CreditsMin = (CheckInventory("DRPGCredits") * LuckMult) / 10;
        int CreditsMax = (CheckInventory("DRPGCredits") * LuckMult);
        int CreditsAmount = Random(CreditsMin, CreditsMax);
        
        // RAINBOWS Event
        if (CurrentLevel->Event == MAPEVENT_BONUS_RAINBOWS)
            CreditsAmount *= 4;
        
        DropMoney(Killer, 0, CreditsAmount);
    };
    
    // Drop stolen ammo
    int Count = 0;
    while (CheckInventory("Clip") >= 10)
    {
        DropMonsterItem(Killer, 0, "DRPGStolenClip", 256);
        TakeInventory("Clip", 10);
        if ((Count++ % 1000) == 0) Delay(1);
    };
    while (CheckInventory("Shell") >= 4)
    {
        DropMonsterItem(Killer, 0, "DRPGStolenShell", 256);
        TakeInventory("Shell", 4);
        if ((Count++ % 1000) == 0) Delay(1);
    };
    while (CheckInventory("RocketAmmo") >= 1)
    {
        DropMonsterItem(Killer, 0, "DRPGStolenRocketAmmo", 256);
        TakeInventory("RocketAmmo", 1);
        if ((Count++ % 1000) == 0) Delay(1);
    };
    while (CheckInventory("Cell") >= 20)
    {
        DropMonsterItem(Killer, 0, "DRPGStolenCell", 256);
        TakeInventory("Cell", 20);
        if ((Count++ % 1000) == 0) Delay(1);
    };
    
    // [KS] We killed this monster now, so if an Arch-vile resurrects it, it doesn't count anymore to re-kill
    // TODO: Need to maybe make sure that for Kill Missions, we can't just gimp Arch-vile resurrection.
    Stats->Flags |= MF_NOXP;
    Stats->Flags |= MF_NODROPS;
    SetActorProperty(0, APROP_RenderStyle, Stats->RenderStyle); // In case of Shadow Aura
    Stats->Target = false;
    Stats->Reinforcement = false;
    
    // [KS] Nuke auras so we don't cause bizarre problems
    RemoveMonsterAura(Stats);
};

acscript void MonsterTransport(int Difficulty, int Time, int Radius)
{
    bool DRLA = (CompatMode == COMPAT_DRLA);
    int MonsterDataAmount;
    MonsterInfoPtr[64] MonsterList;
    int MonsterListLength;
    int BossesSpawned = 0;
    
    // Build a list of monsters
    if (DRLA)
        MonsterDataAmount = MAX_DEF_MONSTERS_DRLA
    else
        MonsterDataAmount = MAX_DEF_MONSTERS;
    
    for (int i = 0; i < MonsterDataAmount && MonsterListLength < 64; i++)
    {
        MonsterInfoPtr TempMonster;
        if (DRLA)
            TempMonster = &MonsterDataDRLA[i]
        else
            TempMonster = &MonsterData[i];
    
        if (TempMonster->Difficulty >= ((Difficulty + 1) * 10) - 40 &&
            TempMonster->Difficulty <= ((Difficulty + 1) * 10) + 10)
            MonsterList[MonsterListLength++] = TempMonster;
    };
    
    if (!MonsterListLength)
    {
        Log("\ciWARNING: \caReinforcement Mission on %s\ca has no monsters!\n", MissionDifficulties[Difficulty]);
        return;
    };
    
    while (true)
    {
        Delay((Time > 0 ? (35 * Time) : -Time));
        
        bool Complete = true;
        fixed X = GetActorX(0);
        fixed Y = GetActorY(0);
        fixed Z = GetActorZ(0);
        int MonsterIndex;
        fixed SpawnX;
        fixed SpawnY;
        int TID;
        bool Success;
        int SpawnTries;
        int CurrentRadius;
        
        // Stop spawning if time is frozen
        while (IsTimeFrozen()) Delay(1);
        
        // Check to see if the mission is complete
        for (int i = 0; i < MAX_PLAYERS; i++)
            if (PlayerInGame(i) && Players(i).Mission.Active && Players(i).Mission.Type == MT_REINFORCEMENTS)
                Complete = false;
        
        // If the mission is complete, terminate
        if (Complete) return;
        
        TID = UniqueTID();
        Success = false;
        SpawnTries = 0;
        CurrentRadius = Radius;
        
        while (!Success && SpawnTries < 3)
        {
            MonsterIndex = Random(0, MonsterListLength - 1);
            
            SpawnX = RandomFixed(-(fixed)CurrentRadius, (fixed)CurrentRadius);
            SpawnY = RandomFixed(-(fixed)CurrentRadius, (fixed)CurrentRadius);
            
            // Get the floor Z position at this spot
            SpawnForced("MapSpot", X + SpawnX, Y + SpawnY, Z, TID, 0);
            Z = GetActorFloorZ(TID);
            Thing_Remove(TID);
            
            Success = Spawn(MonsterList[MonsterIndex]->Actor, X + SpawnX, Y + SpawnY, Z, TID, 0);
            
            bool IsBoss = CheckFlag(TID, "BOSS");
            
            if (Success)
                Success = CheckSight(0, TID, 0);
            if (Success)
                Success = !IsBoss || (!Random (0, 3) && BossesSpawned < 3);
            
            if (!Success)
            {
                // Try again, closer to the player each time, up to 3 times, before giving up.
                Thing_Remove(TID);
                CurrentRadius /= 2;
            }
            else
            {
                if (IsBoss)
                    BossesSpawned++;
            };
            
            SpawnTries++;
        };
        
        if (Success)
        {
            // Delay here to make sure the init script has time to run
            Delay(4);
            
            // Pointer
            MonsterStatsPtr Stats = &Monsters[GetMonsterID(TID)];
            
            Thing_Hate(TID, Player.TID);
            Stats->Reinforcement = true;
            Thing_ChangeTID(TID, 0); // Get rid of the ID

            Spawn("TeleportFog", X + SpawnX, Y + SpawnY, Z, 0, 0);
            
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \c-Reinforcements Spawning Index %d (\ca%s\c-)\n", MonsterIndex, MonsterList[MonsterIndex]->Name);
        };
    };
};

script int WhoKilledMe()
{
    SetActivatorToTarget(0);
    
    // Killed by a player
    if (PlayerNumber() > -1)
        return PlayerNumber();
    
    // Killed by a player's turret
    for (int i = 0; i < MAX_PLAYERS; i++)
        if (ActivatorTID() == Players(i).Turret.TID)
            return i;
    
    // Killed by a player's summons
    if (ClassifyActor(0) & ACTOR_MONSTER && GetMonsterID(0) && GetActorProperty(0, APROP_MasterTID))
    {
        SetActivator(GetActorProperty(0, APROP_MasterTID));
        return PlayerNumber();
    };
    
    // Killed by another monster or the world
    return -1;
};

function void MonsterLevelup(MonsterStatsPtr Stats)
{
    // If the monster is max level, return
    if (Stats->Level >= 1000) return;
    
    // Apply the stats to the monster
    Stats->Level++;
    Stats->Strength += Random(1, GameSkill());
    Stats->Defense += Random(1, GameSkill());
    Stats->Vitality += Random(1, GameSkill());
    Stats->Energy += Random(1, GameSkill());
    Stats->Regeneration += Random(1, GameSkill());
    Stats->Agility += Random(1, GameSkill());
    Stats->Capacity += Random(1, GameSkill());
    Stats->Luck += Random(1, GameSkill());
    
    // Cap the stats
    CapMonsterStats(Stats);
    
    // Spawn Level-up Arrow
    SpawnForced("DRPGLevelUpArrow", GetActorX(0), GetActorY(0), GetActorZ(0) + GetActorPropertyFixed(0, APROP_Height), 0, 0);
    
    if (CheckInventory("DRPGMonsterLevelup"))
        TakeInventory("DRPGMonsterLevelup", 1);
};

function void CapMonsterStats(MonsterStatsPtr Stats)
{
    if (Stats->Level <= 0)
        Stats->Level = 1;
    if (Stats->Level > 1000)
        Stats->Level = 1000;
    if (Stats->Level > 1000)
        Stats->Level = 1000;
    if (Stats->Strength > 1000)
        Stats->Strength = 1000;
    if (Stats->Defense > 1000)
        Stats->Defense = 1000;
    if (Stats->Vitality > 1000)
        Stats->Vitality = 1000;
    if (Stats->Energy > 1000)
        Stats->Energy = 1000;
    if (Stats->Regeneration > 1000)
        Stats->Regeneration = 1000;
    if (Stats->Agility > 1000)
        Stats->Agility = 1000;
    if (Stats->Capacity > 1000)
        Stats->Capacity = 1000;
    if (Stats->Luck > 1000)
        Stats->Luck = 1000;
};

function int CalculateMonsterThreatLevel(MonsterStatsPtr Stats)
{
    int Threat;
    
    // Stats
    Threat += Stats->Strength;
    Threat += Stats->Defense;
    Threat += Stats->Vitality;
    Threat += Stats->Energy;
    Threat += Stats->Regeneration;
    Threat += Stats->Agility;
    Threat += Stats->Capacity;
    Threat += Stats->Luck;
    Threat /= 800;
    
    // Auras
    for (int i = 0; i < AURA_MAX; i++)
        if (Stats->Aura.Type[i].Active)
            Threat++;
    
    // Bosses
    if (CheckFlag(0, "BOSS") || Stats->Flags & MF_BOSS)
        Threat++;
    // Megaboss
    if (Stats->Flags & MF_MEGABOSS)
        Threat += 2;
    
    // DRLA
    if (CompatMode == COMPAT_DRLA)
    {
        str Actor = GetActorClass(0);
        
        for (int i = 0; i < MAX_DEF_MONSTERS_DRLA; i++)
        {
            MonsterInfoPtr MonsterIterPtr = &MonsterDataDRLA[i];
            
            if (StartsWith(Actor, MonsterIterPtr->Actor))
            {
                Threat += MonsterIterPtr->ThreatLevel;
                break;
            };
        };
    };
    
    // Cap
    if (Threat > 10)
        Threat = 10;
    
    return Threat;
};

function int CalculateMonsterMaxHealth(MonsterStatsPtr Stats)
{
    long int Health = Stats->SpawnHealth;
    long int HealthAddition = Stats->SpawnHealth * 9;
    
    HealthAddition *= Stats->Vitality;
    HealthAddition /= 1000;
    
    Health += HealthAddition;
    
    return Health;
};

function fixed CalculateMonsterSpeed(MonsterStatsPtr Stats)
{
    fixed Speed = (fixed)Stats->Speed;
    fixed SpeedMax = Stats->Radius - 1.0;
    
    Speed *= 1.0 + ((fixed)Stats->Agility / 1000.0 * 4.0);
    if (Speed > SpeedMax)
        Speed = SpeedMax;
    
    return Speed;
};

function void RemoveMonsterAura(MonsterStatsPtr Stats)
{
    Stats->Aura.Time = 0;
    Stats->Aura.Team = false;
    
    for (int i = 0; i < AURA_MAX; i++)
    {
        Stats->Aura.Type[i].Active = false;
        Stats->Aura.Type[i].Level = 0;
    };
    
    // Flag Removers
    GiveInventory("DRPGRedAuraRemover", 1);
    GiveInventory("DRPGGreenAuraRemover", 1);
    GiveInventory("DRPGWhiteAuraRemover", 1);
    GiveInventory("DRPGPinkAuraRemover", 1);
    GiveInventory("DRPGBlueAuraRemover", 1);
    GiveInventory("DRPGOrangeAuraRemover", 1);
    
    // Reset Renderstyle
    SetActorProperty(0, APROP_RenderStyle, Stats->RenderStyle);
};

function str DetermineBestStatColor(MonsterStatsPtr Stats)
{
    static str[STAT_MAX] StatColors =
    {
        "\cg";
        "\cd";
        "\ca";
        "\cn";
        "\ct";
        "\ci";
        "\ch";
        "\cf";
    };
    
    int[STAT_MAX] BaseStat;
    int HighestStat = 0;
    int HighestStatType = 0;
    
    if (Stats->Flags & MF_NOSTATS)
        return "\cc";
    
    BaseStat[0] = Stats->Strength;
    BaseStat[1] = Stats->Defense;
    BaseStat[2] = Stats->Vitality;
    BaseStat[3] = Stats->Energy;
    BaseStat[4] = Stats->Regeneration;
    BaseStat[5] = Stats->Agility;
    BaseStat[6] = Stats->Capacity;
    BaseStat[7] = Stats->Luck;
    
    for (int i = 0; i < STAT_MAX; i++)
        if (BaseStat[i] > HighestStat)
        {
            HighestStat = BaseStat[i];
            HighestStatType = i;
        };
    
    return StatColors[HighestStatType];
};

// For Debugging
acscript void OutputMonsters()
{
    for (int i = 1; i < MonsterID; i++)
    {
        Log("\cdMonster %d:\n", i);
        Output Monsters[i];
    };
};
