#include "RPG.dh"

#include "Map.dh"
#include "Mission.dh"
#include "Monsters.dh"
#include "Stats.dh"
#include "Outpost.dh"
#include "Utils.dh"

// Level Info
static DynamicArray KnownLevels;
static LevelInfo *CurrentLevel;
static LevelInfo *PreviousLevel;
static LevelInfo *TransporterLevel;
static LevelInfo *DefaultOutpost;
static int PreviousLevelNum;
static int PreviousPrimaryLevelNum;
static bool UsedSecretExit;
static bool WaitingForReplacements;
static int AllBonusMaps; // For the OCD Shield
static int CurrentSkill; // Keeps track of skill changes based on events

// Local
static int PassingEventTimer;
static bool DisableEvent;

// Map Init Script
script void MapInit() open
{
    // Running the game for the first time
    if (KnownLevels.Data == NULL)
    {
        CurrentSkill = GameSkill() - 1;
        UsedSecretExit = false;
        PreviousLevelSecret = false;
        PreviousLevelNum = 0;
        PreviousPrimaryLevelNum = 0;
        ArrayCreate(&KnownLevels, "LVLS\x00", 32, sizeof(LevelInfo));
        CurrentLevel = NULL;
        PreviousLevel = NULL;
        PassingEventTimer = GetCVar("drpg_mapevent_eventtime") * 35 * 60;
        DisableEvent = true;
        
        if (KnownLevels.Data == NULL)
        {
            Log("\cgWARNING: \caCould not allocate level info!\n");
            return;
        };
        
        // Quick check to add the standard Outpost if we didn't start on it
        if (ThingCountName("DRPGOutpostMarker", 0) == 0 && ThingCountName("DRPGArenaMarker", 0) == 0)
        {
            LevelInfo *OutpostMap = &((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++];
            OutpostMap->LevelNum = 0;
            OutpostMap->LumpName = "OUTPOST";
            OutpostMap->NiceName = "UAC Outpost";
            OutpostMap->Completed = true;
            OutpostMap->UACBase = true;
            OutpostMap->UACArena = false;
            OutpostMap->NeedsRealInfo = false;
            
            DefaultOutpost = OutpostMap;
            
            // [KS] Not right now.
            /*
            LevelInfo *ArenaMap = &((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++];
            ArenaMap->LevelNum = 0;
            ArenaMap->LumpName = "ARENA";
            ArenaMap->NiceName = "UAC Arena";
            ArenaMap->Completed = true;
            ArenaMap->UACArena = true;
            ArenaMap->NeedsRealInfo = false;
            */
        };
    };
    
    CurrentLevel = FindLevelInfo();
    
    if (CurrentLevel == NULL) // New map - We need to create new info for it
    {
        if (KnownLevels.Position == KnownLevels.Size)
            ArrayResize(&KnownLevels);
        
        CurrentLevel = &((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++];
        
        if (KnownLevels.Data == NULL)
        {
            Log("\cgWARNING: \caCould not allocate level info!\n");
            return;
        };
        
        CurrentLevel->LevelNum = 0;
        CurrentLevel->NeedsRealInfo = true;
    };
    
    if (CurrentLevel->NeedsRealInfo)
    {
        // [KS] Is this an outpost or an arena?
        if (ThingCountName("DRPGOutpostMarker", 0) > 0)
        {
            CurrentLevel->LevelNum = 0;
            CurrentLevel->SecretMap = false;
            
            CurrentLevel->LumpName = StrParam("%N\n", PRINTNAME_LEVEL);
            CurrentLevel->NiceName = StrParam("%N\n", PRINTNAME_LEVELNAME);
            
            CurrentLevel->Completed = true;
            CurrentLevel->UACBase = true;
            CurrentLevel->UACArena = false;
            
            CurrentLevel->Event = UACEVENT_NONE;
            CurrentLevel->NeedsRealInfo = false;
        }
        else if (ThingCountName("DRPGArenaMarker", 0) > 0)
        {
            CurrentLevel->LevelNum = 0;
            CurrentLevel->SecretMap = false;
            
            CurrentLevel->LumpName = StrParam("%N\n", PRINTNAME_LEVEL);
            CurrentLevel->NiceName = StrParam("%N\n", PRINTNAME_LEVELNAME);

            CurrentLevel->Completed = true;
            CurrentLevel->UACBase = false;
            CurrentLevel->UACArena = true;
            
            CurrentLevel->Event = UACEVENT_NONE;
            CurrentLevel->NeedsRealInfo = false;
        }
        else
        {
            // [KS] Generate map numbers on the fly based on visitation order and
            // exit usage. The map order for a non-hub is typically a tree - one
            // linear path with optional branching (secret-exit-based) paths that
            // stop in dead ends. Using that knowledge, we can deduce that the maps
            // will travel in a straight line to the end for the most part, and
            // predict the next map number from the last non-secret map that we've
            // discovered.
            
            // This will allow us to not have to rely on LEVELNUM since that can,
            // and most often will, wind up being absent for user maps that provide
            // their own MAPINFO definitions.
            
            if (CurrentLevel->LevelNum == 0)
            {
                PreviousLevelNum++;
                if (!UsedSecretExit)
                    PreviousLevelNum = ++PreviousPrimaryLevelNum;
                
                CurrentLevel->LevelNum = PreviousLevelNum;
                CurrentLevel->SecretMap = UsedSecretExit;
            };
            
            if (GetCVar("drpg_debug"))
                Log ("\cdDEBUG: \cjLevel number: \cd%d\n", CurrentLevel->LevelNum);
            
            CurrentLevel->LumpName = StrParam("%N\n", PRINTNAME_LEVEL);
            CurrentLevel->NiceName = StrParam("%N\n", PRINTNAME_LEVELNAME);
            
            CurrentLevel->UACBase = false;
            CurrentLevel->UACArena = false;
            
            CurrentLevel->Completed = false;
            
            CurrentLevel->MaxMonstersKilled = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
            CurrentLevel->MaxTotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
            CurrentLevel->MaxMonsterPercentage = CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS));
            CurrentLevel->MaxItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
            CurrentLevel->MaxTotalItems = GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
            CurrentLevel->MaxItemPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_ITEMS), GetLevelInfo(LEVELINFO_TOTAL_ITEMS));
            CurrentLevel->MaxSecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
            CurrentLevel->MaxTotalSecrets = GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
            CurrentLevel->MaxSecretPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_SECRETS), GetLevelInfo(LEVELINFO_TOTAL_SECRETS));
            
            // For rank giving and mission counting
            CurrentLevel->UniqueSecrets = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
            
            CurrentLevel->ShortestTime = 0x7FFFFFFF;
            
            // These never change so we don't need to update them
            CurrentLevel->Par = GetLevelInfo(LEVELINFO_PAR_TIME);
            CurrentLevel->Sucks = GetLevelInfo(LEVELINFO_SUCK_TIME);
            
            CurrentLevel->KillBonus = false;
            CurrentLevel->ItemsBonus = false;
            CurrentLevel->SecretsBonus = false;
            CurrentLevel->AllBonus = false;
            CurrentLevel->ParBonus = false;
            
            // Check to see if these are unobtainable
            if (CurrentLevel->MaxTotalMonsters == 0)
                CurrentLevel->KillBonus = true;
            if (CurrentLevel->MaxTotalItems == 0)
                CurrentLevel->ItemsBonus = true;
            if (CurrentLevel->MaxTotalSecrets == 0)
                CurrentLevel->SecretsBonus = true;
            if (CurrentLevel->MaxTotalMonsters == 0 && CurrentLevel->MaxTotalItems == 0 && CurrentLevel->MaxTotalSecrets == 0)
                CurrentLevel->AllBonus = true;
            if (CurrentLevel->Par == 0)
                CurrentLevel->ParBonus = true;
            CalculateBonusMaps();
            
            CurrentLevel->AdditionalMonsters = 0;
            CurrentLevel->Event = MAPEVENT_NONE;
            CurrentLevel->MonsterPositions = BLANKDYNAMICARRAY;
            
            // Allocate the Monster Positions dynamic array
            ArrayCreate(&CurrentLevel->MonsterPositions, "MPOS\x00", 64, sizeof(Position));
            
            // Decide the map's event, if any
            DecideMapEvent(CurrentLevel);
            
            // Tip
            for (int i = 0; i < MAX_PLAYERS; i++)
            {
                // Player is not in-game
                if (!PlayerInGame(i)) continue;
                
                // Player has the tips CVAR disabled
                if (!GetUserCVar(i, "drpg_tips")) continue;
                
                SetActivator(0, AAPTR_PLAYER1 << i);
                GiveTip();
                SetActivator(0, AAPTR_NULL);
            };
            
            CurrentLevel->NeedsRealInfo = false;
        };
        
        // We need to make sure the maps stay sorted whenever we add one
        qsort(KnownLevels.Data, KnownLevels.Position, sizeof(LevelInfo), LevelSort);
    };
    
    // We need to do this again because qsort invalidated all our pointers
    CurrentLevel = FindLevelInfo();
    
    // Transport will take us to the last base we were in.
    if (CurrentLevel->UACBase)
        DefaultOutpost = CurrentLevel;
    
    if (CurrentLevel->UACBase || CurrentLevel->UACArena)
        return; // [KS] These maps set themselves up, so nothing more to do.
    
    WaitingForReplacements = true;
    Delay(2);
    
    // Reduce monster population based on difficulty settings
    static bool WaitLock = true;
    ReduceMonsterCount(&WaitLock);
    while (WaitLock)
        Delay(1);
    
    // Populate the positions array
    for (int i = 1; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        // Array has grown too big, resize it
        if (CurrentLevel->MonsterPositions.Position == CurrentLevel->MonsterPositions.Size)
            ArrayResize(&CurrentLevel->MonsterPositions);
        
        // Store position
        ((Position *)CurrentLevel->MonsterPositions.Data)[CurrentLevel->MonsterPositions.Position++] = Monsters[i].Position;
        
        // Prevent running away on gigantic maps (see holyhell.wad MAP05)
        if ((i % 4096) == 0)
            Delay(1);
    };
    
    // Set up the currently in-effect map event
    SetupMapEvent();
    
    // Also give a tip for events if they're new to the player
    if (CurrentLevel->Event != MAPEVENT_NONE)
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            // Player is not in-game
            if (!PlayerInGame(i)) continue;
            
            // Player has the tips CVAR disabled
            if (!GetUserCVar(i, "drpg_tips")) continue;
            
            // Player has seen this event before
            if (Players(i).SeenEventTip[CurrentLevel->Event]) continue;
            
            SetActivator(Players(i).TID);
            GiveTip();
            SetActivator(0, AAPTR_NULL);
        };
    
    AddAdditionalMonsters();
    
    // Setup missions which require generation
    SetupMapMissions();
    
    DisableEvent = false;
    WaitingForReplacements = false;
    
    // Hell Skill has some additional challenges
    if (GameSkill() >= 5)
    {
        AddMiniboss();
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            HellSkillTransport(i);
        };
    };
    
    if (CurrentLevel)
        MapLoop();
};

script void ReduceMonsterCount(bool *WaitLock)
{
    int TotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
    
    if (TotalMonsters == 0)
    {
        *WaitLock = false;
        return;
    };
    
    if (TotalMonsters * GetCVar("drpg_monster_population") / 100 == TotalMonsters)
    {
        *WaitLock = false;
        return;
    };
    
    int MonstersToRemove = TotalMonsters - (TotalMonsters * GetCVar("drpg_monster_population") / 100);
    
    if (MonstersToRemove < 0)
    {
        MonstersToRemove = -MonstersToRemove;
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: \ccAdding \cd%d\cc more monsters!\n", MonstersToRemove);
        CurrentLevel->AdditionalMonsters = MonstersToRemove;
        *WaitLock = false;
        return;
    };
    
    if (TotalMonsters <= MonstersToRemove)
        MonstersToRemove = TotalMonsters - 1;
    
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: \ccReducing monster count to \cd%d\cc from \cd%d\n", TotalMonsters - MonstersToRemove, TotalMonsters);
    
    int Iterations = 0;
    while (MonstersToRemove)
    {
        for (int i = Random(1, MonsterID - 1); i < MonsterID; i++)
        {
            if (!Monsters[i].Init || ClassifyActor(Monsters[i].TID) == ACTOR_NONE || !(CheckFlag(Monsters[i].TID, "COUNTKILL")))
                continue;
            
            Thing_Remove(Monsters[i].TID);
            Monsters[i].Init = false;
            Monsters[i].TID = 0;
            
            MonstersToRemove--;
            
            break;
        };
        
        Iterations++;
        
        if ((Iterations % 4096) == 0)
            Delay(1);
    };
    
    *WaitLock = false;
};

script void SetupMapMissions()
{
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        // Player is currently not in-game
        if (!PlayerInGame(i)) continue;
        
        // Kill
        if (Players(i).Mission.Active && Players(i).Mission.Type == MT_KILL)
        {
            int Amount = Players(i).Mission.Amount - Players(i).Mission.Current;
            DynamicLootGenerator(GetMissionMonsterActor(Players(i).Mission.Monster->Actor), Amount);
        };
        
        // Assassination
        if (Players(i).Mission.Active && Players(i).Mission.Type == MT_ASSASSINATION)
            DynamicLootGenerator(GetMissionMonsterActor(Players(i).Mission.Monster->Actor), 1);
    };
};

script void MapLoop()
{
    long int XPBonus;
    long int RankBonus;
    
    int ItemsFound;
    int SecretsFound;
    
    int ItemsLastFound = 0;
    
    Delay(5); // Allow Map Events to change the monster/item counts
    
    Start:
    
    // Mission Trackers
    ItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
    SecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
    
    if (ItemsFound > ItemsLastFound)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i) || Players(i).Mission.Type != MT_ITEMS)
                continue;
            
            Players(i).Mission.Current += ItemsFound - ItemsLastFound;
        };
    };
    
    // These should be unique-only, because they're not secrets anymore once
    // you know about them.
    if (SecretsFound > CurrentLevel->UniqueSecrets)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
            
            RankBonus = RankTable[Players(i).RankLevel] / 100;
            Players(i).Rank += RankBonus;
            
            if (Players(i).Mission.Type != MT_SECRETS)
                continue;

            Players(i).Mission.Current += SecretsFound - CurrentLevel->UniqueSecrets;
        };
        
        CurrentLevel->UniqueSecrets = SecretsFound;
    };
    
    // Kills/Item/Secrets special bonuses
    if (CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) > CurrentLevel->MaxMonsterPercentage && CurrentLevel->Event != MAPEVENT_MEGABOSS && CurrentLevel->Event != MAPEVENT_DRLA_OVERMIND && CurrentLevel->Event != MAPEVENT_ONEMONSTER && CurrentLevel->Event != MAPEVENT_DRLA_FEEDINGFRENZY)
    {
        CurrentLevel->MaxMonstersKilled = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
        CurrentLevel->MaxTotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
        CurrentLevel->MaxMonsterPercentage = CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS));
    };
    if (CalcPercent(GetLevelInfo(LEVELINFO_FOUND_ITEMS), GetLevelInfo(LEVELINFO_TOTAL_ITEMS)) > CurrentLevel->MaxItemPercentage)
    {
        CurrentLevel->MaxItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
        CurrentLevel->MaxTotalItems = GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
        CurrentLevel->MaxItemPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_ITEMS), GetLevelInfo(LEVELINFO_TOTAL_ITEMS));
    };
    if (CalcPercent(GetLevelInfo(LEVELINFO_FOUND_SECRETS), GetLevelInfo(LEVELINFO_TOTAL_SECRETS)) > CurrentLevel->MaxSecretPercentage)
    {
        CurrentLevel->MaxSecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
        CurrentLevel->MaxTotalSecrets = GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
        CurrentLevel->MaxSecretPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_SECRETS), GetLevelInfo(LEVELINFO_TOTAL_SECRETS));
    };
    
    if (CurrentLevel->MaxMonsterPercentage >= 100 && !CurrentLevel->KillBonus && CurrentLevel->Event != MAPEVENT_MEGABOSS && CurrentLevel->Event != MAPEVENT_DRLA_OVERMIND && CurrentLevel->Event != MAPEVENT_ONEMONSTER && CurrentLevel->Event != MAPEVENT_DRLA_FEEDINGFRENZY)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 0, 0, 0.25, 255, 0, 0, 0, 1.0);
            
            XPBonus = XPTable[Players(i).Level] / 100;
            Player.XP += XPBonus;
            
            HudMessage("Monsters Killed Bonus!\n%ld XP Bonus\n", XPBonus,
                       HUDMSG_FADEOUT, 0, CR_BRICK, 1.5, 0.4, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->KillBonus = true;
    };

    if (CurrentLevel->MaxItemPercentage >= 100 && !CurrentLevel->ItemsBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(0, 255, 255, 0.25, 0, 255, 255, 0, 1.0);
            
            HealThing(SHIELD_HEALTH);
            Players(i).EP = Players(i).EPMax;
            
            HudMessage("Items Found Bonus!\nFull HP/EP Restore\n",
                       HUDMSG_FADEOUT, 0, CR_LIGHTBLUE, 1.5, 0.6, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->ItemsBonus = true;
    };

    if (CurrentLevel->MaxSecretPercentage >= 100 && !CurrentLevel->SecretsBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
            
            RankBonus = RankTable[Players(i).RankLevel] / 20;
            Players(i).Rank += RankBonus;

            HudMessage("Secrets Found Bonus!\n%ld Rank Bonus\n", RankBonus,
                       HUDMSG_FADEOUT, 0, CR_YELLOW, 1.5, 0.8, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->SecretsBonus = true;
    };
    
    if (CurrentLevel->KillBonus && CurrentLevel->ItemsBonus && CurrentLevel->SecretsBonus && !CurrentLevel->AllBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 255, 255, 0.25, 255, 255, 255, 0, 1.0);
            
            XPBonus = XPTable[Players(i).Level] / 100;
            RankBonus = RankTable[Players(i).RankLevel] / 20;
            
            Players(i).XP += XPBonus;
            Players(i).Rank += RankBonus;
            
            HealThing(SHIELD_HEALTH);
            Players(i).EP = Players(i).EPMax;
            
            HudMessage("\caMonsters Killed Bonus!\n\cnItems Found Bonus!\n\ckSecrets Found Bonus!\n\n\cj%ld XP Bonus\n\ck%ld Rank Bonus\n\cnFull HP/EP Restore\n",
                       XPBonus, RankBonus,
                       HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.2, 5.0, 5.0);
            
            // Payout Bonus Increase
            Players(i).PayBonus++;
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->AllBonus = true;
        CalculateBonusMaps();
    };
    
    if (CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) >= 100 && (CurrentLevel->Event == MAPEVENT_ALLAURAS || CurrentLevel->Event == MAPEVENT_HARMONIZEDAURAS) && !CurrentLevel->EventCompleted)
    {
        // All Auras and Harmonized Destruction events are ended by killing everything on the map
        if (Timer() > 4)
        {
            AmbientSound("misc/secret", 127);
            SetFont("BIGFONT");
            HudMessageBold("Everything falls silent.\n", HUDMSG_FADEOUT, 0, CR_LIGHTBLUE, 0.5, 0.7, 5.0, 5.0);
            SetFont("SMALLFONT");
            MapEventReward();
        };
        
        CurrentLevel->EventCompleted = true;
    };
    
    Delay(1);
    
    ItemsLastFound = ItemsFound;
    
    goto Start;
};

script void CalculateBonusMaps()
{
    int Count = 0;
    
    for (int i = 0; i < KnownLevels.Position; i++)
        if (((LevelInfo *)KnownLevels.Data)[i].AllBonus)
            Count++;
    
    AllBonusMaps = Count;
};

function int LevelSort(void const *Left, void const *Right)
{
    LevelInfo LeftLevel = *((LevelInfo *)Left);
    LevelInfo RightLevel = *((LevelInfo *)Right);
    
    // Sort order: Outpost, Arena, Normal Map, Secret Map
    
    int LeftScore = LeftLevel.LevelNum + (LeftLevel.SecretMap ? 1000 : 0) + (LeftLevel.UACBase ? -2000 : 0) + (LeftLevel.UACArena ? -1000 : 0);
    int RightScore = RightLevel.LevelNum + (RightLevel.SecretMap ? 1000 : 0) + (RightLevel.UACBase ? -2000 : 0) + (RightLevel.UACArena ? -1000 : 0);
    
    if (LeftScore < RightScore) return -1;
    if (LeftScore > RightScore) return 1;
    
    return 0;
};

function void AddAdditionalMonsters()
{
    if (CurrentLevel->AdditionalMonsters < 1 || CurrentLevel->Event == MAPEVENT_MEGABOSS)
        return;
    
    if (CurrentLevel->Event == MAPEVENT_ONEMONSTER)
        DynamicLootGenerator(GetMissionMonsterActor(CurrentLevel->SelectedMonster->Actor), CurrentLevel->AdditionalMonsters)
    else
        DynamicLootGenerator("DRPGGenericMonsterDropper", CurrentLevel->AdditionalMonsters);
};

function LevelInfo *FindLevelInfo(str MapName)
{
    if (MapName == nullptr)
        MapName = StrParam("%N\n", PRINTNAME_LEVEL);
    
    for (int i = 0; i < KnownLevels.Position; i++)
        if (!StrICmp(((LevelInfo *)KnownLevels.Data)[i].LumpName, MapName))
            return &((LevelInfo *)KnownLevels.Data)[i];
    
    return NULL;
};

function int FindLevelInfoIndex(str MapName)
{
    if (MapName == nullptr)
        MapName = StrParam("%N\n", PRINTNAME_LEVEL);
    
    for (int i = 0; i < KnownLevels.Position; i++)
        if (!StrICmp(((LevelInfo *)KnownLevels.Data)[i].LumpName, MapName))
            return i;
    
    return 0; // Default to the Outpost because we don't actually know where we are
};

acscript void AddUnknownMap(str Name, str DisplayName, int LevelNumber, int Secret)
{
    while (KnownLevels.Data == NULL)
        Delay(1);
    
    if (FindLevelInfo(Name) != NULL)
        return; // This map was already unlocked, so ignore it
    
    LevelInfo *NewMap = &((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++];
    NewMap->LumpName = Name;
    NewMap->NiceName = DisplayName;
    NewMap->LevelNum = LevelNumber;
    NewMap->SecretMap = Secret;
    NewMap->UACBase = false;
    NewMap->UACArena = false;
    NewMap->SecretMap = false;
    NewMap->Completed = false;
    NewMap->NeedsRealInfo = true;
};

// Level exit script
// Can't use NamedExecute in xlat, lame
acscript void MapExit(bool Secret) @ MAP_EXIT_SCRIPTNUM
{
    int ParTime = GetLevelInfo(LEVELINFO_PAR_TIME);
    bool Waiting = true;
    
    // Megabosses prevent you from leaving until they are killed
    // Hell Unleashed prevents you from leaving until you have opened the box
    if ((CurrentLevel->Event == MAPEVENT_MEGABOSS && !CurrentLevel->EventCompleted) || (CurrentLevel->Event == MAPEVENT_DRLA_OVERMIND && !CurrentLevel->EventCompleted) || (CurrentLevel->Event == MAPEVENT_HELLUNLEASHED && !CurrentLevel->HellUnleashedActive))
    {
        AmbientSound("mission/gottarget2", 127);
        
        SetHudSize(640, 480, false);
        SetFont("BIGFONT");
        HudMessageBold("\cgA mysterious force prevents you from leaving!\n",
                       HUDMSG_TYPEON | HUDMSG_LOG, 0, CR_RED, 320.4, 160.0, 3.0, 0.03, 0.5);
        SetHudSize(0, 0, false);
        SetFont("SMALLFONT");
        
        // In Hell Unleashed, spawn waves of enemies to spite the player for trying to leave without opening the box
        if (CurrentLevel->Event == MAPEVENT_HELLUNLEASHED && !CurrentLevel->HellUnleashedActive)
            while (!CurrentLevel->HellUnleashedActive)
            {
                HellUnleashedSpawnMonsters();
                Delay(35 * 30);
            };
        
        // Wait until the event is over
        while ((CurrentLevel->Event == MAPEVENT_MEGABOSS && !CurrentLevel->EventCompleted) || (CurrentLevel->Event == MAPEVENT_DRLA_OVERMIND && !CurrentLevel->EventCompleted) || (CurrentLevel->Event == MAPEVENT_HELLUNLEASHED && !CurrentLevel->HellUnleashedActive))
            Delay(35 * 5);
    };
    
    // Environmental Hazard triggers a security lockdown until the hazard level is cleared
    if (CurrentLevel->Event == MAPEVENT_TOXICHAZARD && !CurrentLevel->EventCompleted)
    {
        AmbientSound("transfer/fail", 127);
        
        SetHudSize(640, 480, false);
        SetFont("BIGFONT");
        HudMessageBold("Level \cg%d\c- Security Lockdown is currently in effect.\nCannot transfer until \cjenvironmental hazard\c- is \cjclear\c-.\n", CurrentLevel->HazardLevel,
                       HUDMSG_TYPEON | HUDMSG_LOG, 0, CR_GREEN, 320.4, 160.0, 3.0, 0.03, 0.5);
        SetHudSize(0, 0, false);
        SetFont("SMALLFONT");
        
        while (CurrentLevel->Event == MAPEVENT_TOXICHAZARD && !CurrentLevel->EventCompleted)
            Delay(35 * 5);
    };
    
    // How long it took to reach the exit
    int ExitTime = Timer() / 35;
    if (CurrentLevel->ShortestTime > ExitTime)
        CurrentLevel->ShortestTime = ExitTime;
    
    // Prevent level exit until everyone is outside the menu
    if (InMultiplayer && PlayerCount() > 1)
        while (Waiting)
        {
            Waiting = false;
            
            for (int i = 0; i < MAX_PLAYERS; i++)
                if (Players(i).InMenu || Players(i).InShop || Players(i).OutpostMenu > 0)
                    Waiting = true;
            
            Delay(35 * 3);
        };
    
    // Check par time and give bonus if you beat it
    if (ParTime > 0 && ExitTime < ParTime && (CurrentLevel && !CurrentLevel->ParBonus))
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i)) continue;
            
            SetActivator(Players(i).TID);
            long int RankBonus = RankTable[Players(i).RankLevel] / 20;
            
            SetFont("SMALLFONT");
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0.0, 1.0);
            HudMessage("Par Time Beaten!\n%ld Rank Bonus\n", RankBonus, HUDMSG_FADEOUT, 0, CR_GOLD, 1.5, 0.5, 3.0, 2.0);
            
            Players(i).Rank += RankBonus;
        };
        
        AmbientSound("misc/parbonus", 127);
        
        if (CurrentLevel)
            CurrentLevel->ParBonus = true;
        
        Delay(35 * 5);
    };
    
    if (CurrentLevel->Event == MAPEVENT_TELEPORTCRACKS || CurrentLevel->Event == MAPEVENT_DRLA_FEEDINGFRENZY || CurrentLevel->Event == MAPEVENT_SKILL_HELL || CurrentLevel->Event == MAPEVENT_SKILL_ARMAGEDDON)
        CurrentLevel->EventCompleted = true; // These don't actually end until you leave the map normally
    
    CurrentLevel->Completed = true; // We finished the map
    
    UsedSecretExit = Secret;
    PreviousLevel = CurrentLevel;
    PreviousLevelNum = CurrentLevel->LevelNum;
    if (!CurrentLevel->SecretMap)
        PreviousPrimaryLevelNum = CurrentLevel->LevelNum;

    // Now exit the level
    if (Secret)
        Exit_Secret(0)
    else
        Exit_Normal(0);
};

// Hell Skill modifiers -------------------------------------------------------

// Non-mission version of Assassination
script void AddMiniboss()
{
    if (MonsterID <= 1) return; // No monsters, no miniboss.
    
    int Chosen = Random(1, MonsterID - 1);
    int LevelMod = (4 + (GameSkill() - 5)) * Player.Level + Random(0, 100);
    
    while (!Monsters[Chosen].Init)
        Chosen = Random(1, MonsterID - 1);
    
    Monsters[Chosen].Level += LevelMod;
    Monsters[Chosen].Level /= 4;
    Monsters[Chosen].NeedReinit = true;
    
    // Shadow Aura
    for (int i = 0; i < AURA_MAX; i++)
        Monsters[Chosen].Aura.Type[i].Active = true;
    
    // EVIL LAUGH OF WARNING
    if (Monsters[Chosen].Threat >= 10)
        LocalAmbientSound("mission/gottarget2", 127);
};

// Non-mission version of Reinforcements
script void HellSkillTransport(int player)
{
    SetActivator(Players(player).TID);
    
    bool DRLA = (CompatMode == COMPAT_DRLA);
    int MonsterDataAmount;
    MonsterInfoPtr[MAX_TEMP_MONSTERS] MonsterList;
    int MonsterListLength;
    int BossesSpawned = 0;
    
    // Build a list of monsters
    if (DRLA)
        MonsterDataAmount = MAX_DEF_MONSTERS_DRLA
    else
        MonsterDataAmount = MAX_DEF_MONSTERS;
    
    for (int i = 0; i < MonsterDataAmount && MonsterListLength < MAX_TEMP_MONSTERS; i++)
    {
        MonsterInfoPtr TempMonster;
        if (DRLA)
            TempMonster = &MonsterDataDRLA[i]
        else
            TempMonster = &MonsterData[i];
    
        if (TempMonster->Difficulty <= 2 + AveragePlayerLevel() * 2)
            MonsterList[MonsterListLength++] = TempMonster;
    };
    
    //Log("%d monsters\n", MonsterListLength);
    
    while (CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) < 100)
    {
        Delay(35 * 30);
        
        fixed X = GetActorX(0);
        fixed Y = GetActorY(0);
        fixed Z = GetActorZ(0);
        int MonsterIndex;
        fixed SpawnX;
        fixed SpawnY;
        int TID;
        bool Success;
        int SpawnTries;
        int CurrentRadius;
        
        // Stop spawning if time is frozen
        while (IsTimeFrozen()) Delay(1);
        
        TID = UniqueTID();
        Success = false;
        SpawnTries = 0;
        CurrentRadius = 1024;
        
        while (!Success && SpawnTries < 3)
        {
            MonsterIndex = Random(0, MonsterListLength - 1);
            
            SpawnX = RandomFixed(-(fixed)CurrentRadius, (fixed)CurrentRadius);
            SpawnY = RandomFixed(-(fixed)CurrentRadius, (fixed)CurrentRadius);
            
            // Get the floor Z position at this spot
            SpawnForced("MapSpot", X + SpawnX, Y + SpawnY, Z, TID, 0);
            Z = GetActorFloorZ(TID);
            Thing_Remove(TID);
            
            Success = Spawn(GetMissionMonsterActor(MonsterList[MonsterIndex]->Actor), X + SpawnX, Y + SpawnY, Z, TID, 0);
            
            bool IsBoss = CheckFlag(TID, "BOSS");
            
            if (Success)
                Success = CheckSight(0, TID, 0);
            if (Success)
                Success = !IsBoss || (!Random (0, 3) && BossesSpawned < 3);
            
            if (!Success)
            {
                // Try again, closer to the player each time, up to 3 times, before giving up.
                Thing_Remove(TID);
                CurrentRadius /= 2;
            }
            else
            {
                if (IsBoss)
                    BossesSpawned++;
            };
            
            SpawnTries++;
        };
        
        if (Success)
        {
            //Log("Spawned %s\n", MonsterList[MonsterIndex]->Name);
            Thing_Hate(TID, Player.TID);
            Thing_ChangeTID(TID, 0); // Get rid of the ID
            Spawn("TeleportFog", X + SpawnX, Y + SpawnY, Z, 0, 0);
        };
    };
};

// Map Events -----------------------------------------------------------------

function bool CheckMapEvent(int Event)
{
    switch (Event)
    {
        case MAPEVENT_MEGABOSS:
            if (AveragePlayerLevel() < 50)
                return false;
            return true;
        
        case MAPEVENT_ALLAURAS:
            if (AveragePlayerLevel() < 20)
                return false;
            return true;
        
        case MAPEVENT_HARMONIZEDAURAS:
            if (AveragePlayerLevel() < 10)
                return false;
            return true;
        
        case MAPEVENT_DRLA_FEEDINGFRENZY:
            if (CompatMode != COMPAT_DRLA || AveragePlayerLevel() < 20)
                return false;
            return true;
        
        case MAPEVENT_DRLA_OVERMIND:
            if (CompatMode != COMPAT_DRLA || AveragePlayerLevel() < 40)
                return false;
            return true;
        
        case MAPEVENT_BONUS_RAINBOWS:
            if (Random(0, 15) || !GetCVar("drpg_bonus_events"))
                return false;
            return true;
        
        case MAPEVENT_HELLUNLEASHED:
            if (AveragePlayerLevel() < 20)
                return false;
            return true;
        
        case MAPEVENT_SKILL_HELL:
            if (CurrentSkill >= 4)
                return false;
            return true;
        case MAPEVENT_SKILL_ARMAGEDDON:
            if (CurrentSkill >= 5)
                return false;
            if (CompatMode != COMPAT_DRLA || AveragePlayerLevel() < 10)
                return false;
            return true;
        
        case MAPEVENT_TOXICHAZARD:
        case MAPEVENT_NUCLEARBOMB:
        case MAPEVENT_LOWPOWER:
        case MAPEVENT_ONEMONSTER:
        case MAPEVENT_TELEPORTCRACKS:
        default:
            return true;
    };
    
    return false;
};

function void MapEventReward()
{
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        // Player is not in-game
        if (!PlayerInGame(i)) continue;
        
        SetActivator(Players(i).TID);
        
        if (Player.Level > 0)
        {
            int Credits = 1000 * Player.Level;
            int Modules = 250 * Player.Level;
            str Message = "";
            
            switch (CurrentLevel->Event)
            {
            case MAPEVENT_TOXICHAZARD:
                Message = "Radiation Cleared";
                break;
            case MAPEVENT_NUCLEARBOMB:
                Message = "Bomb Disarmed";
                break;
            case MAPEVENT_LOWPOWER:
                Message = "Backup Power Restored";
                break;
            case MAPEVENT_ALLAURAS:
            case MAPEVENT_ONEMONSTER:
            case MAPEVENT_HARMONIZEDAURAS:
                Message = "Area Secured";
                break;
            };
            
            ActivatorSound("mission/complete", 127);
            PrintMessage(StrParam("\cd%s\n\n\cf+%d Credits\n\cd+%d Modules\n", Message, Credits, Modules));
            GiveInventory("DRPGCredits", Credits);
            GiveInventory("DRPGModule", Modules);
        };
    };
};

script void DecideMapEvent(LevelInfo *TargetLevel, bool FakeIt)
{
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: \chDeciding event for \cd%s\n", TargetLevel->LumpName);

    static str[MAPEVENT_MAX] EventNames =
    {
        "None";
        
        "MegaBoss";
        "Environmental Hazard";
        "Thermonuclear Bomb";
        "Low Power";
        "All Auras";
        "One-Monster";
        "Hell Unleashed";
        "Harmonized Destruction";
        "Cracks in the Veil";
        
        "Feeding Frenzy";
        "Whispers of Darkness";
        
        "RAINBOWS!";
        
        "Skills - Hell";
        "Skills - Armageddon";
    };
    
    if (TargetLevel->UACBase)
        // [KS] One day, there will be invasions. Someday.
        return;
    
    // We need to clear all of the event data before choosing one
    
    TargetLevel->EventCompleted = false;
    
    // Megaboss
    TargetLevel->MegabossActor = NULL;
    
    // Environmental Hazard
    TargetLevel->HazardLevel = 0;
    TargetLevel->RadLeft = 0;
    TargetLevel->GeneratorFuel = 0;
    
    // Thermonuclear Bomb
    TargetLevel->BombTime = 0;
    TargetLevel->BombExplode = false;
    TargetLevel->BombAnnouncing = false;
    for (int i = 0; i < MAX_NUKE_KEYS; i++)
    {
        TargetLevel->BombKeyActive[i] = false;
        TargetLevel->BombKeyDisarming[i] = false;
        TargetLevel->BombKeyTimer[i] = 0;
    };
    
    // Low Power
    TargetLevel->PowerGeneratorActive = false;
    
    // One-Monster
    TargetLevel->SelectedMonster = NULL;
    
    // Hell Unleashed
    TargetLevel->HellUnleashedActive = false;
    TargetLevel->PandoraBoxTID = 0;
    TargetLevel->LevelAdd = 0;
    TargetLevel->RareAdd = 0;
    
    // Harmonized Destruction
    TargetLevel->AuraType = 0;
    
    if (!FakeIt)
    {
        // Don't bother creating an event if the level has no monsters
        if (GetLevelInfo(LEVELINFO_TOTAL_MONSTERS) == 0)
        {
            TargetLevel->Event = MAPEVENT_NONE;
            return;
        };
        
        if (RandomFixed(0.0, 99.9) > GetCVarFixed("drpg_mapevent_chance") || DisableEvent)
        {
            TargetLevel->Event = MAPEVENT_NONE;
            return; // No special event
        };
        
        int Rerolls = 256; // Just in case *no* events are possible for some reason
        while (TargetLevel->Event == MAPEVENT_NONE && Rerolls)
        {
            TargetLevel->Event = Random(MAPEVENT_NONE + 1, MAPEVENT_MAX - 1);
            
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: Trying \cj%s\n", EventNames[TargetLevel->Event]);
            
            if (!CheckMapEvent(TargetLevel->Event))
            {
                if (GetCVar("drpg_debug"))
                    Log("\cdDEBUG: \cj%s\cg not possible\n", EventNames[TargetLevel->Event]);
                TargetLevel->Event = MAPEVENT_NONE;
            };
            
            Rerolls--;
        };
        
        if (TargetLevel->Event == MAPEVENT_NONE)
            return;
    };
    
    if (GetCVar("drpg_debug") && TargetLevel->Event != MAPEVENT_NONE)
        Log("\cdDEBUG: Special Event on \cc%s\cd: \cg%s\n", TargetLevel->NiceName, EventNames[TargetLevel->Event]);
    
    // Initialize some basic info for the chosen event
    
    if (TargetLevel->Event == MAPEVENT_MEGABOSS)
    {
        TargetLevel->MegabossActor = &MegaBosses[Random(0, MAX_MEGABOSSES - 1)];
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Chosen Boss: \cg%s\n", TargetLevel->MegabossActor->Actor);
    }
    else if (TargetLevel->Event == MAPEVENT_TOXICHAZARD)
    {
        TargetLevel->HazardLevel = Random(1, 5);
        TargetLevel->RadLeft = 100;
    }
    else if (TargetLevel->Event == MAPEVENT_ONEMONSTER)
    {
        bool DRLA = (CompatMode == COMPAT_DRLA);
        
        int Amount;
        MonsterInfoPtr[MAX_TEMP_MONSTERS] PotentialMonsters;
        int NumPotentialMonsters;
        int MonsterDataAmount;
        fixed MonsterLevelDivisor;
        
        if (DRLA)
        {
            MonsterDataAmount = MAX_DEF_MONSTERS_DRLA;
            MonsterLevelDivisor = 2.5;
        }
        else
        {
            MonsterDataAmount = MAX_DEF_MONSTERS;
            MonsterLevelDivisor = 1.25;
        };
        
        // Generate a list based on monsters' threat levels.
        for (int i = 0; i < MonsterDataAmount; i++)
        {
            MonsterInfoPtr TempMonster;
            int RequiredLevel;
            int AverageLevel = AveragePlayerLevel();
            
            if (DRLA)
                TempMonster = &MonsterDataDRLA[i]
            else
                TempMonster = &MonsterData[i];
            
            RequiredLevel = (fixed)(TempMonster->Difficulty + ((TempMonster->ThreatLevel) * 20)) / MonsterLevelDivisor;
            RequiredLevel = Clamp(0, RequiredLevel, 80);
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \ccPotential monster: \cg%s \cc/ Needed level: \cg%d\n", TempMonster->Name, RequiredLevel);
            
            if (AverageLevel >= RequiredLevel && TempMonster->ThreatLevel <= 5)
                PotentialMonsters[NumPotentialMonsters++] = TempMonster;
        };
        
        for (int i = 0; i < NumPotentialMonsters; i++)
        
        TargetLevel->SelectedMonster = PotentialMonsters[Random(0, NumPotentialMonsters - 1)];
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Chosen Monster: \cg%s\n", TargetLevel->SelectedMonster->Name);
    }
    else if (TargetLevel->Event == MAPEVENT_HARMONIZEDAURAS)
    {
        TargetLevel->AuraType = Random(0, AURA_MAX);
    };
};

script void PassingEvents() open
{
    while (true)
    {
        if (GetCVar("drpg_mapevent_eventtime") == 0)
            return;
        
        Delay(1);
        PassingEventTimer--;
        
        if (PassingEventTimer <= 0)
        {
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \cfRe-rolling events for all inactive levels\n");
            
            for (int i = 0; i < KnownLevels.Position; i++)
            {
                LevelInfo *ThisLevel = &((LevelInfo *)KnownLevels.Data)[i];
                
                if (!ThisLevel->Completed)
                {
                    if (GetCVar("drpg_debug"))
                        Log("\cdDEBUG: \cgIncomplete: %s\n", ThisLevel->LumpName);
                    continue;
                };
                
                if (CurrentLevel && ThisLevel == CurrentLevel)
                {
                    if (GetCVar("drpg_debug"))
                        Log("\cdDEBUG: \cfCurrent: %s\n", ThisLevel->LumpName);
                    continue;
                };
                
                if (GetCVar("drpg_debug"))
                    Log("\cdDEBUG: \cqInactive: %s\n", ThisLevel->LumpName);
                
                DecideMapEvent(ThisLevel);
            };
            
            PassingEventTimer = GetCVar ("drpg_mapevent_eventtime") * 35 * 60;
        };
    };
};

script void SetupMapEvent()
{
    switch (CurrentLevel->Event)
    {
        // Normal Events
        // --------------------------------------------------
        
        case MAPEVENT_MEGABOSS:
            // Megaboss: One incredibly powerful super-monster spawns, nothing else in level.
            MegaBossEvent();
            break;
        
        case MAPEVENT_TOXICHAZARD:
            // Environmental Hazard: Entire map is filled with damaging radiation. Monsters can drop extra Radiation Suits when killed.
            EnvironmentalHazard();
            break;
        
        case MAPEVENT_NUCLEARBOMB:
            // Thermonuclear Bomb: A Thermonuclear Bomb spawns next to you on map start. You have PAR * 3 to escape before it explodes.
            ThermonuclearBombEvent();
            break;
        
        case MAPEVENT_LOWPOWER:
            // Low Power: Light levels are extremely diminished. IR goggles recommended.
            LowPowerEvent();
            break;
        
        case MAPEVENT_ALLAURAS:
            // All Auras: Everything spawns with evil, evil auras.
            SetMusic("AllAuras");
            SetHudSize(640, 480, false);
            SetFont("BIGFONT");
            HudMessage("The air crackles with the darkest of magics!\n", HUDMSG_FADEOUT, 0, CR_DARKRED, 320.0, 150.0, 1.0, 19.0);
            SetHudSize(0, 0, false);
            break;
        
        case MAPEVENT_ONEMONSTER:
            // One-Monster: All monsters are of a single type.
            OneMonsterEvent();
            break;
        
        case MAPEVENT_HELLUNLEASHED:
            // Hell Unleashed: Monsters will continue to spawn in over time
            // Monster levels and rare drop rates will steadily increase while you stay in the level
            HellUnleashedEvent();
            break;
        
        case MAPEVENT_HARMONIZEDAURAS:
            // Harmonized Destruction: Everything spawns with the same aura.
            HarmonizedDestructionEvent();
            break;
        
        case MAPEVENT_TELEPORTCRACKS:
            // Cracks in the Veil: Portals litter the level, slowly ripping it apart spatially.
            TeleportCracksEvent();
            break;
        
        // DRLA Events
        // --------------------------------------------------
        
        case MAPEVENT_DRLA_FEEDINGFRENZY:
            // T     H     E    Y      4   R    E      C  0   M  I    N   G
            //     %   !  &        F    3   E  D       F   1   E   5   H
            FeedingFrenzyEvent();
            break;
        
        case MAPEVENT_DRLA_OVERMIND:
            // Whispers of Darkness: The Overmind is watching. The Overmind is close. One of us. One of us. One of us.
            WhispersofDarknessEvent();
            break;
        
        // Bonus Events
        // --------------------------------------------------
        
        case MAPEVENT_BONUS_RAINBOWS:
            // RAINBOWS: ALL OF THE COLORS!
            RainbowEvent();
            break;
        
        // Bonus Events
        // --------------------------------------------------
        
        case MAPEVENT_SKILL_HELL:
            if (GameSkill() != 5)
                ChangeLevel(CurrentLevel->LumpName, 0, CHANGELEVEL_NOINTERMISSION, 4);
            SetMusic("Skill5");
            SetHudSize(640, 480, false);
            SetFont("BIGFONT");
            HudMessageBold("It smells of burnt flesh and rotting corpses. It is likely you could be joining them soon.\n", HUDMSG_FADEOUT, 0, CR_BRICK, 320.4, 150.0, 1.0, 19.0);
            SetHudSize(0, 0, false);
            break;
        
        case MAPEVENT_SKILL_ARMAGEDDON:
            if (GameSkill() != 6)
                ChangeLevel(CurrentLevel->LumpName, 0, CHANGELEVEL_NOINTERMISSION, 5);
            SetMusic("Skill6");
            SetHudSize(640, 480, false);
            SetFont("BIGFONT");
            HudMessage("A foul misfortune sweeps the land, turning up the darkest creatures. There is no God now.\n", HUDMSG_FADEOUT, 0, CR_GREY, 320.4, 150.0, 1.0, 19.0);
            SetHudSize(0, 0, false);
            break;
        
        // Standard Level
        // --------------------------------------------------
        
        default:
            break;
    };
};

script void SetupOutpostEvent()
{
    // TODO: Outpost Invasions, Power Fluctuations, etc
    return;
};

script void ResetMapEvent() unloading
{
    // Remove the active event if it's been completed
    if (CurrentLevel && CurrentLevel->Event && CurrentLevel->EventCompleted)
    {
        // And reset the skill for these
        if (CurrentLevel->Event == MAPEVENT_SKILL_HELL || CurrentLevel->Event == MAPEVENT_SKILL_ARMAGEDDON)
            ChangeSkill(CurrentSkill);
        
        CurrentLevel->Event = MAPEVENT_NONE;
        CurrentLevel->EventCompleted = false;
    };
};

function bool SpawnEventActor(str Actor, int TID)
{
    fixed Angle = 1.0 - GetActorAngle(Players(0).TID);
    fixed X = GetActorX(Players(0).TID) + Cos(Angle) * 128.0;
    fixed Y = GetActorY(Players(0).TID) + Sin(Angle) * 128.0;
    fixed Z = GetActorZ(Players(0).TID);
    bool Spawned = Spawn(Actor, X, Y, Z, TID, 0);
    
    if (!CheckSight(TID, Players(0).TID, 0) || !Spawned)
    {
        Thing_Remove(TID);
        return false;
    }
    else
        return true;
};

acscript void SetMapEvent(int Level, int ID)
{
    LevelInfo *MapToChange = NULL;
    
    if (Level == 0)
        MapToChange = CurrentLevel
    else if (Level < 0 || Level >= KnownLevels.Position)
        MapToChange = NULL
    else
        MapToChange = &((LevelInfo *)KnownLevels.Data)[Level];
    
    if (MapToChange == NULL)
    {
        Log("\cgYou attempt black voodoo magic and fail.\n");
        
        if (Random(1, 6) == 1) // Roll for critical failure
            DamageThing(1000000);
        
        return;
    };
    
    MapToChange->Event = ID;
    
    DecideMapEvent(MapToChange, true);
    
    if (CurrentLevel == MapToChange)
        Log("\cjYou will need to warp back to this level to see changes take effect.\n");
};

// Event - Megaboss -----------------------------------------------------------

script void MegaBossEvent()
{
    bool Spawned;
    bool Spotted;
    int TID;
    int BossType;
    int Index;
    Position *ChosenPosition;
    
    // Ambient Music
    SetMusic(StrParam("MBossA%d\n", Random(1, 2)));
    
    // Pick Boss
    CurrentLevel->MegabossActor = &MegaBosses[Random(0, MAX_MEGABOSSES - 1)];
    
    // Replace them with nothing
    for (int i = 1; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        Monsters[i].ReplaceActor = "None";
    };
    
    WaitingForReplacements = false;
    Delay(1); // Monsters disappear!
    
    // Shuffle positions
    for (int i = 0; i < CurrentLevel->MonsterPositions.Position; i++)
    {
        int X = Random(0, CurrentLevel->MonsterPositions.Position - 1);
        Position TempPosition;
        
        TempPosition = ((Position *)CurrentLevel->MonsterPositions.Data)[i];
        ((Position *)CurrentLevel->MonsterPositions.Data)[i] = ((Position *)CurrentLevel->MonsterPositions.Data)[X];
        ((Position *)CurrentLevel->MonsterPositions.Data)[X] = TempPosition;
    };
    
    // Spawning
    while (!Spawned)
    {
        TID = UniqueTID();
        ChosenPosition = &((Position *)CurrentLevel->MonsterPositions.Data)[Index];
        Spawned = Spawn(CurrentLevel->MegabossActor->Actor, ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, TID, ChosenPosition->Angle * 256);
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Iterating for Spawn Point... (Class %s, Index %d, Position %k/%k/%k\n", CurrentLevel->MegabossActor->Actor, Index, ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z);
        
        // Successful spawn
        if (Spawned)
        {
            SpawnForced("TeleportFog", ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, 0, 0);
            GiveActorInventory(TID, "DRPGWhiteAuraGiver", 1);
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \cg%s MegaBoss successfully spawned\n", CurrentLevel->MegabossActor->Actor);
        };
        
        Index++;
        if (Index >= CurrentLevel->MonsterPositions.Position)
            Index = 0;
        
        Delay(1);
    };
    
    // EVIL WARNING LAUGHTER
    AmbientSound("mission/gottarget2", 127);
    
    // Loop
    while (true)
    {
        // Checks to perform while the player has not been spotted
        if (!Spotted)
        {
            // Cycle locations every minute until the player has been spotted
            if ((Timer() % (35 * 60)) == 0)
            {
                SetActivator(TID);
                TeleportMonster();
                SetActivator(0);
            };
            
            // Check LOS
            for (int i = 0; i < MAX_PLAYERS; i++)
                if (CheckSight(TID, Players(i).TID, 0))
                {
                    SetMusic(CurrentLevel->MegabossActor->Music);
                    Spotted = true;
                    break;
                };
        };
        
        // Defeated
        if (GetActorProperty(TID, APROP_Health) <= 0)
        {
            SetMusic("*"); // TODO: Some sort of victory fanfare thingy here?
            Delay(35 * 60); // Let the players pick up the loot
            CurrentLevel->EventCompleted = true;
            return;
        };
        
        Delay(1);
    };
};

// Event - Environmental Hazard -----------------------------------------------

script void EnvironmentalHazard()
{
    // TODO: [03:23:14] <@Yholl/ID> Maybe fill the radiation event with Stalker style singularities that explode into cool stuff when the science machine sciences at them
    bool NeutralizerSpawned = false;
    int NeutralizerTID;
    SetMusic("EvHazard");
    
    Delay (1);
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i))
            continue;
        
        TakeActorInventory(Players(i).TID, "DRPGNeutralizerFuel", 5);
        UseActorInventory(Players(i).TID, "DRPGRadSuit");
        UseActorInventory(Players(i).TID, "RadSuit2"); // DRLA
        
        // [KS] Haaaaaaaax
        GiveActorInventory(Players(i).TID, "DRPGAntiRadiationForMyVoodooDolls", 1);
    };
    
    // Setup
    EnvironmentalHazardSetColors();
    EnvironmentalHazardDamage();
    
    // Spawn the Neutralizer Fuel Tanks
    DynamicLootGenerator("DRPGNeutralizerFuel", 3 * GameSkill() + Random(1, 5));
    
    while (!NeutralizerSpawned)
    {
        NeutralizerTID = UniqueTID();
        NeutralizerSpawned = SpawnEventActor("DRPGRadiationNeutralizer", NeutralizerTID);
        Delay(1);
    };
    
    int CheckPar = GetLevelInfo(LEVELINFO_PAR_TIME);
    if (CheckPar == 0)
        CheckPar = GetCVar("drpg_default_par_seconds"); // Default Par
    
    CheckPar *= 35;
    
    int RadTimeRequired = CheckPar / 100;
    while (CurrentLevel->Event == MAPEVENT_TOXICHAZARD && !CurrentLevel->EventCompleted)
    {
        if (CurrentLevel->GeneratorFuel)
        {
            if (!GetUserVariable(NeutralizerTID, "user_running"))
            {
                SetUserVariable(NeutralizerTID, "user_running", 1);
                Thing_Activate(NeutralizerTID);
            };
            
            CurrentLevel->GeneratorFuel--;
            
            if (Timer() % RadTimeRequired == 0)
            {
                CurrentLevel->RadLeft--;
                
                if (CurrentLevel->RadLeft == 0)
                {
                    CurrentLevel->HazardLevel--;
                    
                    if (CurrentLevel->HazardLevel == 0)
                    {
                        if (GetUserVariable(NeutralizerTID, "user_running"))
                            Thing_Deactivate(NeutralizerTID);
                        EnvironmentalHazardDisarm();
                        return;
                    };
                    
                    CurrentLevel->RadLeft = 100;
                    EnvironmentalHazardSetColors();
                    AmbientSound("radiation/lowered", 127);
                    SetFont("BIGFONT");
                    HudMessageBold("Radiation level reduced to %d\n", CurrentLevel->HazardLevel, HUDMSG_FADEOUT | HUDMSG_LOG, 0, CR_YELLOW, 0.5, 0.25, 2.0, 1.0);
                };
            };
        }
        else
        {
            if (GetUserVariable(NeutralizerTID, "user_running"))
                Thing_Deactivate(NeutralizerTID);
        };
        
        Delay(1);
    };
};

script void EnvironmentalHazardSetColors()
{
    if (CurrentLevel->EventCompleted)
    {
        for (int i = 0; i <= SHORT_MAX; i++)
        {
            Sector_SetColor(i, 255, 255, 255);
            Sector_SetFade(i, 0, 0, 0);
        };
        
        return;
    };
    
    int FadeR = (63  * CurrentLevel->HazardLevel) / 5;
    int FadeG = (131 * CurrentLevel->HazardLevel) / 5;
    int FadeB = (47  * CurrentLevel->HazardLevel) / 5;
    
    int ColorR = 255 - ((192 * CurrentLevel->HazardLevel) / 5);
    int ColorG = 255 - ((124 * CurrentLevel->HazardLevel) / 5);
    int ColorB = 255 - ((208 * CurrentLevel->HazardLevel) / 5);
    
    for (int i = 0; i <= SHORT_MAX; i++)
    {
        Sector_SetColor(i, ColorR, ColorG, ColorB);
        Sector_SetFade(i, FadeR, FadeG, FadeB);
    };
};

script void EnvironmentalHazardDamage()
{
    Delay(32); // Initial buffer to allow players to Transport away if they don't have suits
    
    while (CurrentLevel->HazardLevel)
    {
        int Damage = 20;

        if (CurrentLevel->HazardLevel < 3)
            Damage = 5
        else if (CurrentLevel->HazardLevel < 5)
            Damage = 10;
        
        for (int i = 0; i <= SHORT_MAX; i++)
            SectorDamage(i, Damage, "Radiation", "PowerIronFeet", DAMAGE_PLAYERS | DAMAGE_IN_AIR | DAMAGE_SUBCLASSES_PROTECT);
        
        // Damage Turrets
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            // Player is not in-game
            if (!PlayerInGame(i)) continue;
            
            // Don't have a turret or it isn't out
            if (!Players(i).Turret.Upgrade[TU_BUILD] || !Players(i).Turret.Active) continue;
            
            Thing_Damage2(Players(i).Turret.TID, Damage, "Radiation");
            SetUserVariable(Players(i).Turret.TID, "user_damage_type", DT_RADIATION);
        };
        
        Delay(32);
    };
};

acscript void EnvironmentalHazardRefillGenerator()
{
    int FuelAmount = 35 * 30 * (6 - GameSkill());
    if (FuelAmount < 35 * 30)
        FuelAmount = 35 * 30;
    
    SetActivator(0, AAPTR_TARGET);
    
    if (CurrentLevel->Event != MAPEVENT_TOXICHAZARD || CurrentLevel->EventCompleted)
        return;
    
    if (!CheckInventory("DRPGNeutralizerFuel"))
        return;
    
    if (CurrentLevel->GeneratorFuel >= FuelAmount)
        return;
    
    TakeInventory("DRPGNeutralizerFuel", 1);
    CurrentLevel->GeneratorFuel = FuelAmount;
    
    AmbientSound("radiation/refuel", 127);
    SetFont("BIGFONT");
    HudMessageBold("Generator refueled\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.25, 2.0, 1.0);
};

script void EnvironmentalHazardDisarm()
{
    if (CurrentLevel->Event != MAPEVENT_TOXICHAZARD || CurrentLevel->EventCompleted)
        return;
    
    EnvironmentalHazardSetColors();
    CurrentLevel->EventCompleted = true;
    
    SetMusic("*");
    
    SetFont("BIGFONT");
    HudMessageBold("Radiation cleared\n", HUDMSG_FADEOUT | HUDMSG_LOG, 0, CR_GREEN, 0.5, 0.25, 2.0, 1.0);
    AmbientSound("radiation/cleared", 127);
    
    MapEventReward();
};

// Event - Thermonuclear Bomb -------------------------------------------------

script void ThermonuclearBombEvent()
{
    int BombTID = UniqueTID();
    int MaxKeys = GameSkill() + 3;
    bool BombSpawned = false;
    bool BombDisarmed = false;
    
    // Calculate bomb time
    CurrentLevel->BombTime = (GetLevelInfo(LEVELINFO_PAR_TIME) ? GetLevelInfo(LEVELINFO_PAR_TIME) * 2 : GetCVar("drpg_default_par_seconds") * 2) * 35;
    
    // Reset key states
    for (int i = 0; i < MAX_NUKE_KEYS; i++)
    {
        CurrentLevel->BombKeyActive[i] = false;
        CurrentLevel->BombKeyDisarming[i] = false;
    };
    
    // Setup Keys
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: \c-Generating %d keys for bomb\n", MaxKeys);
    while (MaxKeys > 0)
    {
        int RandomKey = Random(0, MAX_NUKE_KEYS - 1);
        
        if (!CurrentLevel->BombKeyActive[RandomKey])
        {
            CurrentLevel->BombKeyActive[RandomKey] = true;
            CurrentLevel->BombKeyTimer[RandomKey] = CurrentLevel->BombTime / MAX_NUKE_KEYS * 2;
            MaxKeys--;
        };
        
        Delay(1);
    };
    
    // Spawn the Bomb
    while (!BombSpawned)
    {
        BombSpawned = SpawnEventActor("DRPGThermonuclearBomb", BombTID);
        Delay(1);
    };
    
    SetMusic("");
    
    Delay(35);
    
    // Warning message
    SetHudSize(640, 480, false);
    SetFont("BIGFONT");
    HudMessageBold("\cgWARNING! WARNING!\n\c[White]THERMONUCLEAR BOMB ACTIVATED!\n\ciTIME UNTIL DETONATION: %s\n",
                   FormatTime(CurrentLevel->BombTime), HUDMSG_TYPEON, 0, CR_RED, 320.4, 160.0, 3.0, 0.03, 0.5);
    AmbientSound("nuke/alert", 127);
    SetHudSize(0, 0, false);
    
    Delay(35 * 4);
    
    SetMusic("Bomb");
    
    // Set bomb's active state
    SetActorState(BombTID, "SpawnActive");
    
    // Bomb Loop
    while (CurrentLevel->BombTime > 0 && !BombDisarmed && !CurrentLevel->BombExplode)
    {
        // Announcements
        ThermonuclearBombAnnounce(CurrentLevel->BombTime);
        
        // Acceleration handling
        fixed Velocity = AbsFixed(GetActorVelX(BombTID)) + AbsFixed(GetActorVelX(BombTID));
        if (Velocity > 0)
            PlaySound(BombTID, "nuke/beep", CHAN_BODY, 1.0, true, ATTN_NORM)
        else
            StopSound(BombTID, CHAN_BODY);
        if (Velocity > 7.5) // WHOOPS, you made it angry, now die
            CurrentLevel->BombExplode = true;
        
        // Decrease key timers if the key is being disarmed, also disarm the specified lock if disarming is finished
        for (int i = 0; i < MAX_NUKE_KEYS; i++)
        {
            if (CurrentLevel->BombKeyDisarming[i])
                CurrentLevel->BombKeyTimer[i]--;
            
            if (CurrentLevel->BombKeyDisarming[i] && CurrentLevel->BombKeyTimer[i] <= 0)
            {
                CurrentLevel->BombKeyActive[i] = false;
                CurrentLevel->BombKeyDisarming[i] = false;
                PlaySound(BombTID, "nuke/unlock", CHAN_ITEM, 1.0, false, ATTN_NORM);
            };
        };
        
        // Disarm the bomb if all keys are disarmed
        int DisarmCount = 0;
        for (int i = 0; i < MAX_NUKE_KEYS; i++)
            if (!CurrentLevel->BombKeyActive[i])
                DisarmCount++;
        if (DisarmCount >= MAX_NUKE_KEYS)
        {
            CurrentLevel->BombTime = 0;
            BombDisarmed = true;
        };
        
        CurrentLevel->BombTime--;
        Delay(1);
    };
    
    // Successful disarm
    if (BombDisarmed)
    {
        CurrentLevel->EventCompleted = true;
        
        SetActorState(BombTID, "Disarmed");
        SetUserVariable(BombTID, "user_disarmed", 1);
        AmbientSound("nuke/disarmed", 127);
        SetMusic("*");
        
        MapEventReward();
    }
    else if (!BombDisarmed || CurrentLevel->BombExplode) // Epic failure, explode everyone to die
    {
        SetActorState(BombTID, "Explode");
        
        CurrentLevel->EventCompleted = true;
        
        SetMusic("");
        
        Delay(35 * 5);
        SetMusic("*");
    };
    
    // Remove all keys from the players
    while (true)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
            for (int j = 0; j < MAX_NUKE_KEYS; j++)
                SetActorInventory(Players(i).TID, StrParam("DRPGNukeKey%d\n", j + 1), 0);
        
        Delay(1);
    };
};

script void ThermonuclearBombAnnounce(int Time)
{
    int Minutes = Time / 60 / 35;
    int Seconds = Time / 35 % 60;
    bool ValidMinutes = (Minutes == 1 || Minutes == 2 || Minutes == 3 || Minutes == 4 || Minutes == 5 || Minutes == 10 || Minutes == 20);
    bool ValidSeconds = (Seconds == 0 || Seconds == 1 || Seconds == 2 || Seconds == 3 || Seconds == 4 || Seconds == 5 || Seconds == 10 || Seconds == 20 || Seconds == 30);
    
    // Return if there is currently an announcement playing
    if (CurrentLevel->BombAnnouncing) return;
    
    if (ValidMinutes || ValidSeconds)
    {
        CurrentLevel->BombAnnouncing = true;
        
        // Minutes
        if (Minutes > 0 && ValidMinutes && Seconds == 0)
        {
            AmbientSound("nuke/announce1", 127);
            Delay(35 * 1.9);
            AmbientSound("nuke/announce2", 127);
            Delay(35 * 1.4);
            AmbientSound(StrParam("nuke/minutes/%d\n", Minutes), 127);
        };
        
        // Seconds
        if (Minutes == 0 && ValidSeconds)
        {
            AmbientSound(StrParam("nuke/seconds/%d\n", Seconds), 127);
            Delay(35);
        };
    };
    
    CurrentLevel->BombAnnouncing = false;
};

acscript void ThermonuclearBombActivate()
{
    SetActivator(GetActorProperty(0, APROP_TargetTID));
    
    for (int i = 0; i < MAX_NUKE_KEYS; i++)
        if (CheckInventory(StrParam("DRPGNukeKey%d\n", i + 1)))
        {
            CurrentLevel->BombKeyActive[i] = false;
            TakeInventory(StrParam("DRPGNukeKey%d\n", i + 1), 1);
        };
    
    for (int i = 0; i < MAX_NUKE_KEYS; i++)
    {
        if (!CurrentLevel->BombKeyActive[i]) continue;
        
        if (!CurrentLevel->BombKeyDisarming[i])
        {
            CurrentLevel->BombKeyDisarming[i] = true;
            break;
        }
        else
            break;
    };
};

acscript void ThermonuclearBombExplode()
{
    CurrentLevel->BombExplode = true;
};

// Event - Low Power ----------------------------------------------------------

script void LowPowerEvent()
{
    int GeneratorTID = UniqueTID();
    bool GeneratorSpawned = false;
    
    AmbientSound("misc/poweroff", 127);
    SetMusic("LowPower");
    CurrentLevel->EventCompleted = true; // This event disappears when you leave
    DynamicLootGenerator("DRPGLowPowerJunkSpawner", Random(50, 100));
    
    // Darken all the sectors
    for (int i = 0; i <= SHORT_MAX; i++)
    {
        Light_Stop(i);
        Light_Flicker(i, 48, 96);
        Sector_SetColor(i, 64, 96, 255, 0);
    };
    
    // Spawn the Generator
    while (!GeneratorSpawned)
    {
        GeneratorSpawned = SpawnEventActor("DRPGGenerator", GeneratorTID);
        Delay(1);
    };
    
    // Wait until the generator is powered back up
    while (!CurrentLevel->PowerGeneratorActive)
        Delay(1);
    
    // Generator is now active - Activate emergency lighting
    AmbientSound("misc/poweron", 127);
    SetActorState(GeneratorTID, "PoweredUp");
    SetUserVariable(GeneratorTID, "user_powered", 1);
    for (int i = 0; i <= SHORT_MAX; i++)
    {
        Light_Stop(i);
        Light_Glow(i, 160, 96, 35 * 3);
        Sector_SetColor(i, 255, 128, 32, 0);
    };
    MapEventReward();
    
    // Remove generator power cells from the players
    while (true)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            SetActorInventory(Players(i).TID, "DRPGGeneratorCell", 0);
            SetActorInventory(Players(i).TID, "DRPGGeneratorCellDead", 0);
        };
        
        Delay(1);
    };
};

acscript void PowerGeneratorActivate()
{
    SetActivator(GetActorProperty(0, APROP_TargetTID));
    
    if (CheckInventory("DRPGGeneratorCell"))
    {
        CurrentLevel->PowerGeneratorActive = true;
        TakeInventory("DRPGGeneratorCell", 1);
    };
};

// Event - One-Monster --------------------------------------------------------

script void OneMonsterEvent()
{
    bool Extras = (CompatMode == COMPAT_EXTRAS);
    bool DRLA = (CompatMode == COMPAT_DRLA);

    for (int i = 0; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        Monsters[i].ReplaceActor = GetMissionMonsterActor(CurrentLevel->SelectedMonster->Actor);
    };
    
    // Level feeling
    SetHudSize(640, 480, false);
    SetFont("BIGFONT");
    HudMessage("%s\n", CurrentLevel->SelectedMonster->Feeling, HUDMSG_FADEOUT, 0, CR_BRICK, 320.4, 150.0, 1.0, 19.0);
    SetHudSize(0, 0, false);
    
    Delay(35); // Allow the replacements to actually spawn.
    
    while (ThingCountName(GetMissionMonsterActor(CurrentLevel->SelectedMonster->Actor), 0) > 0)
        Delay(1);
    
    AmbientSound("misc/secret", 127);
    HudMessageBold("Everything falls silent.\n", HUDMSG_FADEOUT, 0, CR_LIGHTBLUE, 0.5, 0.7, 5.0, 5.0);
    MapEventReward();
    
    CurrentLevel->EventCompleted = true;
};

// Event - Hell Unleashed -----------------------------------------------------

script void HellUnleashedEvent()
{
    bool BoxSpawned = false;
    
    // Generate a TID for the box
    CurrentLevel->PandoraBoxTID = UniqueTID();
    
    // Spawn Pandora's Box
    while (!BoxSpawned && !CurrentLevel->HellUnleashedActive)
    {
        BoxSpawned = SpawnEventActor("DRPGPandoraBox", CurrentLevel->PandoraBoxTID);
        Delay(35);
    };
    
    Start:
    
    while (CurrentLevel->HellUnleashedActive >= 2)
    {
        fixed ParTime = (fixed)GetLevelInfo(LEVELINFO_PAR_TIME);
        if (ParTime <= 0) // Assign a default value to prevent divide-by-zero
            ParTime = 35 * GetCVar("drpg_default_par_seconds"); // Default Par
        fixed AddMult = 0.1 / ParTime;
        
        // Cap this to make sure it isn't too low
        if (AddMult < 0.001)
            AddMult = 0.001;
        
        // Spawn in next wave of enemies
        if ((Timer() % (35 * (int)(ParTime / GameSkill()))) == 0)
            HellUnleashedSpawnMonsters();
        
        // Slowly increment the values
        CurrentLevel->LevelAdd += RandomFixed(AddMult, AddMult * 1.0);
        CurrentLevel->RareAdd += RandomFixed(AddMult * 0.01, AddMult * 0.1);
        
        // Level Imposed Caps
        if (CurrentLevel->LevelAdd > (fixed)AveragePlayerLevel() * (fixed)GameSkill())
            CurrentLevel->LevelAdd = (fixed)AveragePlayerLevel() * (fixed)GameSkill();
        if (CurrentLevel->RareAdd > AveragePlayerLevel() / 10.0)
            CurrentLevel->RareAdd = AveragePlayerLevel() / 10.0;
        
        // Hard Caps
        if (CurrentLevel->LevelAdd > 1000)
            CurrentLevel->LevelAdd = 1000;
        if (CurrentLevel->RareAdd > 100)
            CurrentLevel->RareAdd = 100;
        
        Delay(1);
    };
    
    Delay(1);
    goto Start;
};

acscript void HellUnleashedStart()
{
    // Spit out a rare item for each player
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i)) continue;
        
        ItemInfoPtr Item = GetRewardItem(MAX_DIFFICULTIES - 1);
        int ItemTID = UniqueTID();
        fixed X = GetActorX(CurrentLevel->PandoraBoxTID);
        fixed Y = GetActorY(CurrentLevel->PandoraBoxTID);
        fixed Z = GetActorZ(CurrentLevel->PandoraBoxTID) + 16.0;
        
        SpawnForced(Item->Actor, X, Y, Z, ItemTID, 0);
        SetActorVelocity(ItemTID, RandomFixed(-4.0, 4.0), RandomFixed(-4.0, 4.0), RandomFixed(2.0, 8.0), true, false);
    };
    
    CurrentLevel->HellUnleashedActive = 1;
    
    Delay(35 * 8);
    
    CurrentLevel->HellUnleashedActive = 2;
    
    // Spawn an initial wave of enemies
    HellUnleashedSpawnMonsters();
    
    SetMusic("HellUnle");
};

script void HellUnleashedSpawnMonsters()
{
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: \caHell Unleashed \c-- Spawning next wave of monsters...\n");
    
    Delay(1); // Maximize our instructions
    
    for (int i = 0; i < CurrentLevel->MonsterPositions.Position; i++)
    {
        int TID = UniqueTID();
        Position *CurrentPosition = &((Position *)CurrentLevel->MonsterPositions.Data)[i];; // Totally leaving this typo here because IT'S CRYING OKAY, I AM TOO
        
        // Determine a monster
        MonsterInfoPtr Monster;
        if (CompatMode == COMPAT_DRLA)
            Monster = &MonsterDataDRLA[Random(0, MAX_DEF_MONSTERS_DRLA - 1)]
        else
            Monster = &MonsterData[Random(0, MAX_DEF_MONSTERS - 1)];
        
        bool Success = Spawn(Monster->Actor, CurrentPosition->X, CurrentPosition->Y, CurrentPosition->Z, TID, CurrentPosition->Angle);
        if (Success)
            Spawn("TeleportFog", CurrentPosition->X, CurrentPosition->Y, CurrentPosition->Z, 0, CurrentPosition->Angle);
        
        // Stagger the loop here so that we can make monsters appear to spawn in semi-randomly
        Delay(Random(1, 10));
        
        // Setup Stats
        MonsterStatsPtr Stats = &Monsters[GetMonsterID(TID)];
        Stats->Level += (int)CurrentLevel->LevelAdd;
        Stats->NeedReinit = true;
    };
};

// Event - Harmonized Destruction ---------------------------------------------

script void HarmonizedDestructionEvent()
{
    if (AveragePlayerLevel() < 20 && CurrentLevel->AuraType == AURA_MAX)
        CurrentLevel->AuraType = Random(0, AURA_MAX - 1);
    
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: Aura type %d\n", CurrentLevel->AuraType);
    
    for (int i = 0; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        if (CurrentLevel->AuraType == AURA_MAX)
        {
            for (int j = 0; j < AURA_MAX; j++)
                Monsters[i].Aura.Type[j].Active = true;
        }
        else
            Monsters[i].Aura.Type[CurrentLevel->AuraType].Active = true;
        
        Monsters[i].Flags &= MF_NOAURAGEN; // Don't let our aura get overwritten
    };
    
    // Level feeling
    SetMusic("OneAura");
    SetHudSize(640, 480, false);
    SetFont("BIGFONT");
    if (CurrentLevel->AuraType != AURA_MAX)
        HudMessage("A strange, malicious harmony fills the air.\n", HUDMSG_FADEOUT, 0, CR_DARKRED, 320.0, 150.0, 1.0, 19.0)
    else
        HudMessage("A strange, malicious harmony fills the air.\nAnd frankly, it's terrifying.\n", HUDMSG_FADEOUT, 0, CR_DARKRED, 320.0, 150.0, 1.0, 19.0);
    SetHudSize(0, 0, false);
};

// Event - Cracks in the Veil -------------------------------------------------

script void TeleportCracksEvent()
{
    SetMusic("Cracks");
    
    // Shuffle positions
    for (int i = 0; i < CurrentLevel->MonsterPositions.Position; i++)
    {
        int X = Random(0, CurrentLevel->MonsterPositions.Position - 1);
        Position TempPosition;
        
        TempPosition = ((Position *)CurrentLevel->MonsterPositions.Data)[i];
        ((Position *)CurrentLevel->MonsterPositions.Data)[i] = ((Position *)CurrentLevel->MonsterPositions.Data)[X];
        ((Position *)CurrentLevel->MonsterPositions.Data)[X] = TempPosition;
    };
    
    // Spawn the cracks
    for (int i = 0; i < CurrentLevel->MonsterPositions.Position - 1; i += 2)
    {
        if (Random(0, 3))
            continue;
        
        Position Source = ((Position *)CurrentLevel->MonsterPositions.Data)[i];
        Position Destination = ((Position *)CurrentLevel->MonsterPositions.Data)[i + 1];
        int InPortalTID = UniqueTID();
        if (!Spawn("DRPGTeleportCrackIn", Source.X, Source.Y, Source.Z, InPortalTID, Source.Angle * 256))
            continue;
        
        int OutPortalTID = UniqueTID();
        if (!Spawn("DRPGTeleportCrackOut", Destination.X, Destination.Y, Destination.Z, OutPortalTID, Destination.Angle * 256))
        {
            Thing_Remove(InPortalTID);
            continue;
        };
        
        TeleporterCrack(InPortalTID, OutPortalTID);
    };
    
    // Crack effects
    while (true)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i)) continue;
            
            // Quake
            Radius_Quake2(Players(i).TID, 4, 20, 0, 16, "world/quake");
            
            // View Fuckery
            if (!Random(0, 3))
                TeleporterCrackView(i);
        };
        
        AmbientSound("misc/teleport", 127);
        
        Delay(Random(35 * 2, 35 * 20));
    };
};

script void TeleporterCrackView(int PlayerID)
{
    SetActivator(Players(PlayerID).TID);
    fixed ViewTimeMax = 35.0 * RandomFixed(1.0, 3.0);
    fixed ViewTime = 0;
    fixed Intensity = RandomFixed(1.0, 5.0);
    
    Start:
    
    if (ViewTime >= ViewTimeMax) return;
    
    SetHudSize(640, 480, true);
    SetFont(StrParam("P%iVIEW\n", PlayerID + 1));
    
    fixed ViewCycle = Timer() / (120.0 - (10.0 * Intensity));
    fixed ViewDist = 25.0 * Intensity * (ViewTime++ / ViewTimeMax);
    fixed Angle1 = RandomFixed(0.0, 1.0);
    fixed Angle2 = RandomFixed(0.0, 1.0);
    
    // View Intensification
    HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID + 2, CR_UNTRANSLATED, 320, 240, 0.029);
    HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID, CR_UNTRANSLATED,
               320 + (int)(ViewDist * Cos(Angle1)),
               240 + (int)(ViewDist * Sin(Angle1)),
               0.029, 0.6 - (ViewTime / ViewTimeMax) / 2.0);
    HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID + 1, CR_UNTRANSLATED,
               320 + (int)(ViewDist * Cos(Angle2)),
               240 + (int)(ViewDist * Sin(Angle2)),
               0.029, 0.6 - (ViewTime / ViewTimeMax) / 2.0);
    
    Delay(1);
    goto Start;
};

script void TeleporterCrack(int Source, int Destination)
{
    bool DRLA = (CompatMode == COMPAT_DRLA);
    int SpawnEnemyTimer = 0;
    bool CloseToPlayer;
    
    Start:
    CloseToPlayer = false;
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (Distance(Source, Players(i).TID) <= 32.0)
            TeleportOther(Players(i).TID, Destination, true);
        
        if (Distance(Destination, Players(i).TID) <= 2048.0)
            CloseToPlayer = true;
    };
    
    if (++SpawnEnemyTimer >= 263 && Random(1, 4096) == 1 && CloseToPlayer)
    {
        str TempMonster;
        if (DRLA)
            TempMonster = "RLArmageddonPainElemental"
        else
            TempMonster = "ArchVile";
        
        if (SpawnSpotFacing(GetMissionMonsterActor(TempMonster), Destination))
            SpawnSpotFacing("TeleportFog", Destination);
        
        SpawnEnemyTimer = 0;
    };
    
    Delay(4);
    goto Start;
};

// DRLA Event - Feeding Frenzy ------------------------------------------------

script void FeedingFrenzyEvent()
{
    bool Spawned;
    bool Spotted;
    int TID;
    int BossType;
    int Index;
    Position *ChosenPosition;
    
    SetMusic("");
    
    for (int i = 0; i <= SHORT_MAX; i++)
    {
        Light_Stop(i);
        Light_Glow(i, 64, 96, 35 * 30);
        Sector_SetColor(i, 255, 64, 64, 128);
    };
    
    // Replace them with corpses
    for (int i = 1; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        Monsters[i].ReplaceActor = "DRPGRLGibbedStuff";
    };
    
    WaitingForReplacements = false;
    
    Delay(35 * 10);
    
    // Ambient Music
    SetMusic("FeedThem");
    
    int ActiveHungry = 0;
    int LastActiveHungry = 0;
    int KilledHungry = 0;
    
    for (int i = 0; i < MAX_PLAYERS; i++)
        FeedingFrenzyVisualHorror(i);
    
    while (ThingCountName("RLArmageddonLostSoulRPG", 0) < 10)
    {
        Position SpawnPosition = ((Position *)CurrentLevel->MonsterPositions.Data)[Random(0, CurrentLevel->MonsterPositions.Position)];
        
        int SpotTID = UniqueTID();
        
        Spawn("MapSpot", SpawnPosition.X, SpawnPosition.Y, SpawnPosition.Z, SpotTID, SpawnPosition.Angle * 256);
        
        bool VisibleToPlayer = false;
        
        for (int i = 0; i < MAX_PLAYERS; i++)
            if (CheckSight(SpotTID, Players(i).TID, CSF_NOBLOCKALL))
                VisibleToPlayer = true;
        
        Thing_Remove(SpotTID);
        
        if (VisibleToPlayer)
            continue;
        
        Spawn("RLArmageddonLostSoulRPG", SpawnPosition.X, SpawnPosition.Y, SpawnPosition.Z, 0, SpawnPosition.Angle * 256);
    };
    
    while (true)
    {
        ActiveHungry = ThingCountName("RLArmageddonLostSoulRPG", 0);
        
        if (ActiveHungry < LastActiveHungry)
            KilledHungry += (LastActiveHungry - ActiveHungry) * GameSkill();
        
        for (int i = 0; i < CurrentLevel->MonsterPositions.Position; i++)
        {
            if (ThingCountName("RLArmageddonLostSoulRPG", 0) >= 100)
                break;
            
            if (Random(0, 1200) > KilledHungry)
                continue;
            
            Position SpawnPosition = ((Position *)CurrentLevel->MonsterPositions.Data)[i];
            
            int SpotTID = UniqueTID();
            
            Spawn("MapSpot", SpawnPosition.X, SpawnPosition.Y, SpawnPosition.Z, SpotTID, SpawnPosition.Angle * 256);
            
            bool VisibleToPlayer = false;
            
            for (int i = 0; i < MAX_PLAYERS; i++)
                if (CheckSight(SpotTID, Players(i).TID, CSF_NOBLOCKALL))
                    VisibleToPlayer = true;
            
            Thing_Remove(SpotTID);
            
            if (VisibleToPlayer)
                continue;
            
            Spawn("RLArmageddonLostSoulRPG", SpawnPosition.X, SpawnPosition.Y, SpawnPosition.Z, 0, SpawnPosition.Angle * 256);
        };
        
        Delay(35 * 5);
        
        LastActiveHungry = ActiveHungry;
    };
};

script void FeedingFrenzyVisualHorror(int PlayerID)
{
    SetActivator(0, AAPTR_PLAYER1 << PlayerID);
    
    Start:
    
    NoiseAlert(0, 0);
    
    SetHudSize(640, 480, true);
    SetFont(StrParam("P%iVIEW\n", PlayerID + 1));
    
    HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID, CR_UNTRANSLATED,
               320 + Random(-8, 8),
               240 + Random(-8, 8),
               0.029, 0.25);
    
    Delay(1);
    goto Start;
};

// DRLA Event - Whispers of Darkness ------------------------------------------

script void WhispersofDarknessEvent()
{
    bool Spawned;
    bool Spotted;
    int TID;
    int BossType;
    int Index;
    int MonsterIndex;
    Position *ChosenPosition;
    
    // Ambient Music
    SetMusic("Overmind", 0);
    
    // Sector Lighting
    for (int i = 0; i <= SHORT_MAX; i++)
    {
        Sector_SetColor(i, 255, 0, 0, 255);
        Light_Glow(i, 160, 192, 30);
    };
    
    // Replace them with nothing
    for (int i = 1; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        Monsters[i].ReplaceActor = "None";
    };
    
    WaitingForReplacements = false;
    Delay(1); // Monsters disappear!
    
    // Shuffle positions
    for (int i = 0; i < CurrentLevel->MonsterPositions.Position; i++)
    {
        int X = Random(0, CurrentLevel->MonsterPositions.Position - 1);
        Position TempPosition;
        
        TempPosition = ((Position *)CurrentLevel->MonsterPositions.Data)[i];
        ((Position *)CurrentLevel->MonsterPositions.Data)[i] = ((Position *)CurrentLevel->MonsterPositions.Data)[X];
        ((Position *)CurrentLevel->MonsterPositions.Data)[X] = TempPosition;
    };
    
    // Spawning
    while (!Spawned)
    {
        TID = UniqueTID();
        ChosenPosition = &((Position *)CurrentLevel->MonsterPositions.Data)[Index];
        Spawned = Spawn("RLCyberneticSpiderMastermindRPG", ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, TID, ChosenPosition->Angle * 256);
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Iterating for Spawn Point... (Class %s, Index %d, Position %k/%k/%k\n", CurrentLevel->MegabossActor->Actor, Index, ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z);
        
        // Successful spawn
        if (Spawned)
        {
            SpawnForced("TeleportFog", ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, 0, 0);
            Delay(1);
            MonsterIndex = GetMonsterID(TID);
            
            Monsters[MonsterIndex].Level += ((250 / MAX_PLAYERS) * PlayerCount());
            Monsters[MonsterIndex].Level /= 4;
            Monsters[MonsterIndex].NeedReinit = true;
            
            // Shadow Aura
            for (int i = 0; i < AURA_MAX; i++)
                Monsters[MonsterIndex].Aura.Type[i].Active = true;

            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \cgShadow Overmind successfully spawned\n");
        };
        
        Index++;
        if (Index >= CurrentLevel->MonsterPositions.Position)
            Index = 0;
        
        Delay(1);
    };
    
    AmbientSound("spiderovermind/whisper", 127);
    
    // Horrible, horrible things.
    WhispersofDarknessBackgroundCreepiness();
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i))
            continue;
        
        WhispersofDarknessMindRaper(i);
        WhispersofDarknessVisionIntensifier(i);
    };
    
    // Loop
    while (true)
    {
        if (!Spotted)
        {
            // Check LOS
            for (int i = 0; i < MAX_PLAYERS; i++)
                if (CheckSight(TID, Players(i).TID, 0))
                {
                    SetMusic("Overmind", 1);
                    Spotted = true;
                    break;
                };
        };
        
        // Defeated
        if (GetActorProperty(TID, APROP_Health) <= 0)
        {
            SetMusic("");
            CurrentLevel->EventCompleted = true;
            return;
        };
        
        Delay(1);
    };
};

script void WhispersofDarknessBackgroundCreepiness()
{
    AmbientSound("misc/gzdoom.exe", 127);
    Delay(1);
    while (true)
    {
        if ((Timer() % 5565) == 0)
            AmbientSound("misc/gzdoom.exe", 127);
        
        Delay(1);
    };
};

script void WhispersofDarknessMindRaper(int PlayerID)
{
    Start:
    
    SetActivator(0, AAPTR_PLAYER1 << PlayerID);
    
    if (CurrentLevel->EventCompleted)
        return;
    
    if (GetActorProperty(0, APROP_Health) <= 0)
    {
        Delay(35);
        goto Start;
    };
    
    if (GetActorProperty(0, APROP_Health) == 1)
    {
        SetPlayerProperty(0, false, PROP_BUDDHA);
        SetPlayerProperty(0, false, PROP_INVULNERABILITY);
        Thing_Damage2(0, 6666666, "Mindrape");
        ActivatorSound("spiderovermind/laugh", 127);
    }
    else
        SetActorProperty(0, APROP_Health, GetActorProperty(0, APROP_Health) - 1);
    
    Delay(Random(35, 70));
    goto Start;
};

script void WhispersofDarknessVisionIntensifier(int PlayerID)
{
    int MindblastTime = 1;
    int MindblastTimeMax = 1;
    bool ShowOvermind = false;
    
    Start:
    
    SetActivator(0, AAPTR_PLAYER1 << PlayerID);
    
    if (CurrentLevel->EventCompleted)
        return;
    
    if (GetActorProperty(0, APROP_Health) <= 0)
    {
        Delay(35);
        goto Start;
    };
    
    if (--MindblastTime == 0)
    {
        Delay(Random(35 * 20, 35 * 60));
        
        MindblastTime = Random(35 * 2, 35 * 4);
        MindblastTimeMax = MindblastTime;
    };
    
    if (MindblastTime == MindblastTimeMax)
    {
        if (!Random(0, 7))
            StatusEffect(SE_BLIND, Random(30, 60), Random(1, 5));
        
        if (!Random(0, 7))
            StatusEffect(SE_CONFUSION, Random(30, 60), Random(1, 5));
        
        if (!Random(0, 3))
        {
            ShowOvermind = true;
            for (int i = 0; i < CurrentLevel->MonsterPositions.Position; i++)
            {
                if (!Random(0, 7))
                    continue;
                
                Position SpawnPosition = ((Position *)CurrentLevel->MonsterPositions.Data)[i];
                
                int SpotTID = UniqueTID();
                
                Spawn("MapSpot", SpawnPosition.X, SpawnPosition.Y, SpawnPosition.Z, SpotTID, SpawnPosition.Angle * 256);
                
                bool VisibleToPlayer = false;
                
                for (int i = 0; i < MAX_PLAYERS; i++)
                    if (CheckSight(SpotTID, Players(i).TID, CSF_NOBLOCKALL))
                        VisibleToPlayer = true;
                
                Thing_Remove(SpotTID);
                
                if (!VisibleToPlayer)
                    continue;
                
                if (!Spawn("RLCyberneticArachnotronRPG", SpawnPosition.X, SpawnPosition.Y, SpawnPosition.Z, 0, SpawnPosition.Angle * 256))
                    Spawn("RLCyberneticImpRPG", SpawnPosition.X, SpawnPosition.Y, SpawnPosition.Z, 0, SpawnPosition.Angle * 256);
            };
        };
        
        if (ShowOvermind)
            LocalAmbientSound("spiderovermind/laugh", 127)
        else
            LocalAmbientSound("spiderovermind/whisper", 32);
    };
    
    SetHudSize(640, 480, true);
    
    SetFont(StrParam("P%iVIEW\n", PlayerID + 1));
    HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID + 1, CR_UNTRANSLATED,
               320 + Random(-8, 8),
               240 + Random(-8, 8),
               0.029, (((fixed)MindblastTime / (fixed)MindblastTimeMax) * 0.66));
    
    if (ShowOvermind)
    {
        SetFont("OVERMIND");
        HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, CONFUSION_ID, CR_UNTRANSLATED,
                   320 + Random(-4, 4),
                   240 + Random(-4, 4),
                   0.029, (((fixed)MindblastTime / (fixed)MindblastTimeMax) * 0.66));
    };
    
    Delay(1);
    
    goto Start;
};

// Bonus Events ---------------------------------------------------------------

script void RainbowEvent()
{
    SetMusic("RAINBOWS");
    CurrentLevel->EventCompleted = true; // Disappears when we leave
    
    fixed Angle = 0;
    int Red, Green, Blue;
    
    for (int i = 0; i <= SHORT_MAX; i++)
        Light_ChangeToValue(i, 176);
    
    Delay(1);
    
    Start:
    Angle -= 1.0 / 350;
    if (Angle < 0.0) Angle = 1.0 + Angle;
    Red = 128 + (Sin(Angle) * 128.0);
    Green = 128 + (Sin(Angle + 0.33) * 128.0);
    Blue = 128 + (Sin(Angle + 0.67) * 128.0);
    
    for (int i = 0; i <= SHORT_MAX; Sector_SetColor(i++, Red, Green, Blue, 128));
    
    Delay(1);
    goto Start;
};
